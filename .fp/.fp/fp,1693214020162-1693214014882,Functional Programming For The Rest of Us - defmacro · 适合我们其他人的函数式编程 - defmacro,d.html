<!DOCTYPE html> <html lang=en style><!--
 Page saved with SingleFile 
 url: https://www.defmacro.org/2006/06/19/fp.html 
 saved date: Mon Aug 28 2023 17:13:40 GMT+0800 (中国标准时间)
--><meta charset=utf-8>
<meta http-equiv=X-UA-Compatible content="IE=edge">
<meta name=viewport content="width=device-width, initial-scale=1">
<title>Functional Programming For The Rest of Us | defmacro · 适合我们其他人的函数式编程 | defmacro</title>
<meta name=generator content="Jekyll v3.9.2">
<meta property=og:title content="Functional Programming For The Rest of Us">
<meta name=author content="Slava Akhmechet">
<meta property=og:locale content=en_US>
<meta name=description content="Introduction Programmers are procrastinators. Get in, get some coffee, check the mailbox, read the RSS feeds, read the news, check out latest articles on techie websites, browse through political discussions on the designated sections of the programming forums. Rinse and repeat to make sure nothing is missed. Go to lunch. Come back, stare at the IDE for a few minutes. Check the mailbox. Get some coffee. Before you know it, the day is over. The only thing, every once in a while challenging articles actually do pop up. If you're looking at the right places you'll find at least one of these every couple of days. These articles are hard to get through and take some time, so they start piling up. Before you know it, you have a list of links and a folder full of PDF files and you wish you had a year in a small hut in the middle of the forest with nobody around for miles so you could catch up. Would be nice if someone came in every morning while you're taking a walk down the river to bring some food and take out the garbage. I don't know about your list, but a large chunk of the articles in mine are about functional programming. These generally are the hardest to get through. Written in a dry academic language, even the &quot;ten year Wall Street industry veterans&quot; don't understand what functional programming (also referred to as FP) articles are all about. If you ask a project manager in Citi Group or in Deutsche Bank1 why they chose to use JMS instead of Erlang they'll say they can't use academic languages for industrial strength applications. The problem is, some of the most complex systems with the most rigid requirements are written using functional programming elements. Something doesn't add up. It's true that FP articles and papers are hard to understand, but they don't have to be. The reasons for the knowledge gap are purely historical. There is nothing inherently hard about FP concepts. Consider this article &quot;an accessible guide to FP&quot;, a bridge from our imperative minds into the world of FP. Grab a coffee and keep on reading. With any luck your coworkers will start making fun of you for your FP comments in no time. So what is FP? How did it come about? Is it edible? If it's as useful as its advocates claim, why isn't it being used more often in the industry? Why is it that only people with PhDs tend to use it? Most importantly, why is it so damn hard to learn? What is all this closure, continuation, currying, lazy evaluation and no side effects business? How can it be used in projects that don't involve a university? Why does it seem to be so different from everything good, and holy, and dear to our imperative hearts? We'll clear this up very soon. Let's start with explaining the reasons for the huge gap between the real world and academic articles. The answer is as easy as taking a walk in the park. A Walk In The Park Fire up the time machine. Our walk in the park took place more than two thousand years ago, on a beautiful sunny day of a long forgotten spring in 380 B.C. Outside the city walls of Athens, under the pleasant shade of olive trees Plato was walking towards the Academy with a beautiful slave boy. The weather was lovely, the dinner was filling, and the conversation turned to philosophy. &quot;Look at these two students&quot;, said Plato carefully picking words to make the question educational. &quot;Who do you think is taller?&quot; The slave boy looked towards the basin of water where two men were standing. &quot;They're about the same height&quot;, he said. &quot;What do you mean 'about the same'?&quot;, asked Plato. &quot;Well, they look the same from here but I'm sure if I were to get closer I'd see that there is some difference.&quot; Plato smiled. He was leading the boy in the right direction. &quot;So you would say that there is nothing perfectly equal in our world?&quot; After some thinking the boy replied: &quot;I don't think so. Everything is at least a little different, even if we can't see it.&quot; The point hit home! &quot;Then if nothing is perfectly equal in this world, how do you think you understand the concept of 'perfect' equality?&quot; The slave boy looked puzzled. &quot;I don't know&quot;, he replied. So was born the first attempt to understand the nature of mathematics. Plato suggested that everything in our world is just an approximation of perfection. He also realized that we understand the concept of perfection even though we never encountered it. He came to conclusion that perfect mathematical forms must live in another world and that we somehow know about them by having a connection to that &quot;alternative&quot; universe. It's fairly clear that there is no perfect circle that we can observe. But we also understand what a perfect circle is and can describe it via equations. What is mathematics, then? Why is the universe described with mathematical laws? Can all of the phenomena of our universe be described by mathematics?2 Philosophy of mathematics is a very complex subject. Like most philosophical disciplines it is far more adept at posing questions rather than providing answers. Much of the consensus revolves around the fact that mathematics is really a puzzle: we set up a set of basic non-conflicting principles and a set of rules on how to operate with these principles. We can then stack these rules together to come up with more complex rules. Mathematicians call this method a &quot;formal system&quot; or a &quot;calculus&quot;. We can effectively write a formal system for Tetris if we wanted to. In fact, a working implementation of Tetris is a formal system, just specified using an unusual representation. A civilization of furry creatures on Alpha Centauri would not be able to read our formalisms of Tetris and circles because their only sensory input might be an organ that senses smells. They likely will never find out about the Tetris formalism, but they very well might have a formalism for circles. We probably wouldn't be able to read it because our sense of smell isn't that sophisticated, but once you get past the representation of the formalism (via various sensory instruments and standard code breaking techniques to understand the language), the concepts underneath are understandable to any intelligent civilization. Interestingly if no intelligent civilization ever existed in the universe the formalisms for Tetris and circles would still hold water, it's just that nobody would be around to find out about them. If an intelligent civilization popped up, it would likely discover some formalisms that help describe the laws of our universe. They also would be very unlikely to ever find out about Tetris because there is nothing in the universe that resembles it. Tetris is one of countless examples of a formal system, a puzzle, that has nothing to do with the real world. We can't even be sure that natural numbers have full resemblance to the real world, after all one can easily think of a number so big that it cannot describe anything in our universe since it might actually turn out to be finite. A Bit of History3 Let's shift gears in our time machine. This time we'll travel a lot closer, to the 1930s. The Great Depression was ravaging the New and the Old worlds. Almost every family from every social class was affected by the tremendous economic downturn. Very few sanctuaries remained where people were safe from the perils of poverty. Few people were fortunate enough to be in these sanctuaries, but they did exist. Our interest lies in mathematicians in Princeton University. The new offices constructed in gothic style gave Princeton an aura of a safe haven. Logicians from all over the world were invited to Princeton to build out a new department. While most of America couldn't find a piece of bread for dinner, high ceilings, walls covered with elaborately carved wood, daily discussions by a cup of tea, and walks in the forest were some of the conditions in Princeton. One mathematician living in such lavish lifestyle was a young man named Alonzo Church. Alonzo received a B.S. degree from Princeton and was persuaded to stay for graduate school. Alonzo felt the architecture was fancier than necessary. He rarely showed up to discuss mathematics with a cup of tea and he didn't enjoy the walks in the woods. Alonzo was a loner: he was most productive when working on his own. Nevertheless Alonzo had regular contacts with other Princeton inhabitants. Among them were Alan Turing, John von Neumann, and Kurt Gödel. The four men were interested in formal systems. They didn't pay much heed to the physical world, they were interested in dealing with abstract mathematical puzzles instead. Their puzzles had something in common: the men were working on answering questions about computation. If we had machines that had infinite computational power, what problems would we be able to solve? Could we solve them automatically? Could some problems remain unsolved and why? Would various machines with different designs be equal in power? In cooperation with other men Alonzo Church developed a formal system called lambda calculus. The system was essentially a programming language for one of these imaginary machines. It was based on functions that took other functions as parameters and returned functions as results. The function was identified by a Greek letter lambda, hence the system's name4. Using this formalism Alonzo was able to reason about many of the above questions and provide conclusive answers. Independently of Alonzo Church, Alan Turing was performing similar work. He developed a different formalism (now referred to as the Turing machine), and used it to independently come to similar conclusions as Alonzo. Later it was shown that Turing machines and lambda calculus were equivalent in power. This is where the story would stop, I'd wrap up the article, and you'd navigate to another page, if not for the beginning of World War II. The world was in flames. The U.S. Army and Navy used artillery more often than ever. In attempts to improve accuracy the Army employed a large group of mathematicians to continuously calculate differential equations required for solving ballistic firing tables. It was becoming obvious that the task was too great for being solved manually and various equipment was developed in order to overcome this problem. The first machine to solve ballistic tables was a Mark I built by IBM - it weighed five tons, had 750,000 parts and could do three operations per second. The race, of course, wasn't over. In 1949 an Electronic Discrete Variable Automatic Computer (EDVAC) was unveiled and had tremendous success. It was a first example of von Neumann's architecture and was effectively a real world implementation of a Turing machine. For the time being Alonzo Church was out of luck. In late 1950s an MIT professor John McCarthy (also a Princeton graduate) developed interest in Alonzo Church's work. In 1958 he unveiled a List Processing language (Lisp). Lisp was an implementation of Alonzo's lambda calculus that worked on von Neumann computers! Many computer scientists recognized the expressive power of Lisp. In 1973 a group of programmers at MIT's Artificial Intelligence Lab developed hardware they called a Lisp machine - effectively a native hardware implementation of Alonzo's lambda calculus! Functional Programming Functional programming is a practical implementation of Alonzo Church's ideas. Not all lambda calculus ideas transform to practice because lambda calculus was not designed to work under physical limitations. Therefore, like object oriented programming, functional programming is a set of ideas, not a set of strict guidelines. There are many functional programming languages, and most of them do many things very differently. In this article I will explain the most widely used ideas from functional languages using examples written in Java (yes, you could write functional programs in Java if you felt particularly masochistic). In the next couple of sections we'll take Java as is, and will make modifications to it to transform it into a useable functional language. Let's begin our quest. Lambda calculus was designed to investigate problems related to calculation. Functional programming, therefore, primarily deals with calculation, and, surprisingly, uses functions to do so. A function is a very basic unit in functional programming. Functions are used for almost everything, even the simplest of calculations. Even variables are replaced with functions. In functional programming variables are simply aliases for expressions (so we don't have to type everything on one line). They cannot be modified. All variables can only be assigned to once. In Java terms this means that every single variable is declared as final (or const if we're dealing with C++). There are no non-final variables in FP. final int i = 5; final int j = i + 3; Since every variable in FP is final two fairly interesting statements can be made. It does not make sense to always write the keyword final and it does not make sense to call variables, well... variables. We will now make two modifications to Java: every variable declared in our functional Java will be final by default, and we will refer to variables as symbols. By now you are probably wondering how you could possibly write anything reasonably complicated in our newly created language. If every symbol is non-mutable we cannot change the state of anything! This isn't strictly true. When Alonzo was working on lambda calculus he wasn't interested in maintaining state over periods of time in order to modify it later. He was interested in performing operations on data (also commonly referred to as &quot;calculating stuff&quot;). However, it was proved that lambda calculus is equivalent to a Turing machine. It can do all the same things an imperative programming language can. How, then, can we achieve the same results? It turns out that functional programs can keep state, except they don't use variables to do it. They use functions instead. The state is kept in function parameters, on the stack. If you want to keep state for a while and every now and then modify it, you write a recursive function. As an example, let's write a function that reverses a Java string. Remember, every variable we declare is final by default5. String reverse(String arg) { if(arg.length == 0) { return arg; } else { return reverse(arg.substring(1, arg.length)) + arg.substring(0, 1); } } This function is slow because it repeatedly calls itself6. It's a memory hog because it repeatedly allocates objects. But it's functional in style. You may be interested why someone would want to program in this manner. Well, I was just about to tell you. Benefits of FP You're probably thinking that there's no way I can rationalize the monstrosity of a function above. When I was learning functional programming I was thinking that too. I was wrong. There are very good arguments for using this style. Some of them are subjective. For example, people claim that functional programs are easier to understand. I will leave out these arguments because every kid on the block knows that ease of understanding is in the eye of the beholder. Fortunately for me, there are plenty of objective arguments. Unit Testing Since every symbol in FP is final, no function can ever cause side effects. You can never modify things in place, nor can one function modify a value outside of its scope for another function to use (like a class member or a global variable). That means that the only effect of evaluating a function is its return value and the only thing that affects the return value of a function is its arguments. This is a unit tester's wet dream. You can test every function in your program only worrying about its arguments. You don't have to worry about calling functions in the right order, or setting up external state properly. All you need to do is pass arguments that represent edge cases. If every function in your program passes unit tests you can be a lot more confident about quality of your software than if you were using an imperative language. In Java or C++ checking a return value of a function is not sufficient - it may modify external state that we would need to verify. Not so in a functional language. Debugging If a functional program doesn't behave the way you expect it to, debugging it is a breeze. You will always be able to reproduce your problem because a bug in a functional program doesn't depend on unrelated code paths that were executed before it. In an imperative program a bug resurfaces only some of the time. Because functions depend on external state produced by side effects from other functions you may have to go through a series of steps in no way related to the bug. In a functional program this isn't the case - if a return value of a function is wrong, it is always wrong, regardless of what code you execute before running the function. Once you reproduce the problem, getting to the bottom of it is trivial. It is almost pleasant. You break the execution of your program and examine the stack. Every argument in every function call in the stack is available for your inspection, just like in an imperative program. Except in an imperative program that's not enough because functions depend on member variables, global variables, and the state of other classes (which in turn depend on these very same things). A function in a functional program depends only on its arguments, and that information is right before your eyes! Furthermore, in an imperative program examining a return value of a function will not give you a good idea of whether the function behaves properly. You need to hunt down dozens of objects outside its scope to verify that it performed correct actions. In a functional program all you have to do is look at the return value! Walking through the stack you look at arguments passed to functions and their return values. The minute a return value doesn't make sense you step into the offending function and walk through it. You repeat this recursively until the process leads you to the source of the bug! Concurrency A functional program is ready for concurrency without any further modifications. You never have to worry about deadlocks and race conditions because you don't need to use locks! No piece of data in a functional program is modified twice by the same thread, let alone by two different threads. That means you can easily add threads without ever giving conventional problems that plague concurrency applications a second thought! If this is the case, why doesn't anybody use functional programs for highly concurrent applications? Well, it turns out that they do. Ericsson designed a functional language called Erlang for use in its highly tolerant and scalable telecommunication switches. Many others recognized the benefits provided by Erlang and started using it. We're talking about telecommunication and traffic control systems that are far more scalable and reliable than typical systems designed on Wall Street. Actually, Erlang systems are not scalable and reliable. Java systems are. Erlang systems are simply rock solid. The concurrency story doesn't stop here. If your application is inherently single threaded the compiler can still optimize functional programs to run on multiple CPUs. Take a look at the following code fragment: String s1 = somewhatLongOperation1(); String s2 = somewhatLongOperation2(); String s3 = concatenate(s1, s2); In a functional language the compiler could analyze the code, classify the functions that create strings s1 and s2 as potentially time consuming operations, and run them concurrently. This is impossible to do in an imperative language because each function may modify state outside of its scope and the function following it may depend on it. In functional languages automatic analysis of functions and finding good candidates for concurrent execution is as trivial as automatic inlining! In this sense functional style programs are &quot;future proof&quot; (as much as I hate buzzwords, I'll indulge this time). Hardware manufacturers can no longer make CPUs run any faster. Instead they increase the number of cores and attribute quadruple speed increases to concurrency. Of course they conveniently forget to mention that we get our money's worth only on software that deals with parallelizable problems. This is a very small fraction of imperative software but 100% of functional software because functional programs are all parallelizable out of the box. Hot Code Deployment In the old days of Windows in order to install updates it was necessary to restart the computer. Many times. After installing a newer version of a media players. With Windows XP the situation has improved significantly, yet it still isn't ideal (I ran Windows Update at work today and now an annoying system tray icon won't go away until I restart). Unix systems have had a better model for a while. In order to install an update you only need to stop relevant components, not the whole OS. While it is a better situation, for a large class of server applications it still isn't acceptable. Telecommunication systems need to be up 100% of the time because if dialing emergency is not available due to upgrades, lives may be lost. There is no reason Wall Street firms need to bring down their systems to install software updates over the weekend. An ideal situation is updating relevant parts of the code without stopping any part of the system at all. In an imperative world this isn't possible. Consider unloading a Java class at runtime and reloading a new definition. If we were to do that every instance of a class would become unusable because the state it holds would be lost. We would need to resort to writing tricky version control code. We'd need to serialize all running instances of the class, destroy them, create instances of the new class, try to load serialized data into them hoping the loading code properly migrates the data to work with the new instance. On top of that, every time we change something we'd have to write our migration code manually. And our migration code would have to take special care not to break relationships between objects. Nice in theory, but would never work well in practice. In a functional program all state is stored on the stack in the arguments passed to functions. This makes hot deployment significantly easier! In fact, all we'd really have to do is run a diff between the code in production and the new version, and deploy the new code. The rest could be done by language tools automatically! If you think this is science fiction, think again. Erlang engineers have been upgrading live systems without stopping them for years. Machine Assisted Proofs and Optimizations An interesting property of functional languages is that they can be reasoned about mathematically. Since a functional language is simply an implementation of a formal system, all mathematical operations that could be done on paper still apply to the programs written in that language. The compiler could, for example, convert pieces of code into equivalent but more efficient pieces with a mathematical proof that two pieces of code are equivalent7. Relational databases have been performing these optimizations for years. There is no reason the same techniques can't apply to regular software. Additionally, you can use these techniques to prove that parts of your program are correct. It is even possible to create tools that analyze code and generate edge cases for unit tests automatically! This functionality is invaluable for rock solid systems. If you are designing pace makers and air traffic control systems such tools are almost always a requirement. If you are writing an application outside of truly mission critical industries, these tools can give you a tremendous edge over your competitors. Higher Order Functions I remember learning about the benefits I outlined above and thinking &quot;that's all very nice but it's useless if I have to program in a crippled language where everything is final.&quot; This was a misconception. Making all variables final is crippled in a context of an imperative language like Java but it isn't in a context of functional languages. Functional languages offer a different kind of abstraction tools that make you forget you've ever liked modifying variables. One such tool is capability to work with higher order functions. A function in such languages is different from a function in Java or C. It is a superset - it can do all the things a Java function can do, and more. We create a function in the same manner we do in C: int add(int i, int j) { return i + j; } This means something different from equivalent C code. Let's extend our Java compiler to support this notation. When we type something like this our compiler will convert it to the following Java code (don't forget, everything is final): class add_function_t { int add(int i, int j) { return i + j; } } add_function_t add = new add_function_t(); The symbol add isn't really a function. It is a small class with one function as its member. We can now pass add around in our code as an argument to other functions. We can assign it to another symbol. We can create instances of add_function_t at runtime and they will be garbage collected when we no longer need them. This makes functions first class objects no different from integers or strings. Functions that operate on other functions (accept them as arguments) are called higher order functions. Don't let this term intimidate you, it's no different from Java classes that operate on each other (we can pass class instances to other classes). We can call them &quot;higher order classes&quot; but nobody cares to because there is no strong academic community behind Java. How, and when, do you use higher order functions? Well, I'm glad you asked. You write your program as a big monolithic blob of code without worrying about class hierarchies. When you see that a particular piece of code is repeated, you break it out into a function (fortunately they still teach this in schools). If you see that a piece of logic within your function needs to behave differently in different situations, you break it out into a higher order function. Confused? Here's a real life example from my work. Suppose we have a piece of Java code that receives a message, transforms it in various ways, and forwards it to another server. class MessageHandler { void handleMessage(Message msg) { // ... msg.setClientCode(&quot;ABCD_123&quot;); // ... sendMessage(msg); } // ... } Now imagine that our system has changed and we now route messages to two servers instead of one. Everything is handled in exactly the same way except the client code - the second server wants it in a different format. How do we handle this situation? We could check where the message is headed and format the client code differently, like this: class MessageHandler { void handleMessage(Message msg) { // ... if(msg.getDestination().equals(&quot;server1&quot;) { msg.setClientCode(&quot;ABCD_123&quot;); } else { msg.setClientCode(&quot;123_ABC&quot;); } // ... sendMessage(msg); } // ... } This approach, however, isn't scalable. If more servers are added our function will grow linearly and we'll have a nightmare updating it. An object oriented approach is to make MessageHandler a base class and specialize the client code operation in derived classes: abstract class MessageHandler { void handleMessage(Message msg) { // ... msg.setClientCode(getClientCode()); // ... sendMessage(msg); } abstract String getClientCode(); // ... } class MessageHandlerOne extends MessageHandler { String getClientCode() { return &quot;ABCD_123&quot;; } } class MessageHandlerTwo extends MessageHandler { String getClientCode() { return &quot;123_ABCD&quot;; } } We can now instantiate an appropriate class for each server. Adding servers becomes much more maintainable. That's a lot of code for such a simple modification though. We have to create two new types just to support different client codes! Now let's do the same thing in our language that supports higher order functions: class MessageHandler { void handleMessage(Message msg, Function getClientCode) { // ... Message msg1 = msg.setClientCode(getClientCode()); // ... sendMessage(msg1); } // ... } String getClientCodeOne() { return &quot;ABCD_123&quot;; } String getClientCodeTwo() { return &quot;123_ABCD&quot;; } MessageHandler handler = new MessageHandler(); handler.handleMessage(someMsg, getClientCodeOne); We've created no new types and no class hierarchy. We simply pass appropriate functions as a parameter. We've achieved the same thing as the object oriented counterpart with a number of advantages. We don't restrict ourselves to class hierarchies: we can pass new functions at runtime and change them at any time with a much higher degree of granularity with less code. Effectively the compiler has written object oriented &quot;glue&quot; code for us! In addition we get all the other benefits of FP. Of course the abstractions provided by functional languages don't stop here. Higher order functions are just the beginning. Currying Most people I've met have read the Design Patterns book by the Gang of Four. Any self respecting programmer will tell you that the book is language agnostic and the patterns apply to software engineering in general, regardless of which language you use. This is a noble claim. Unfortunately it is far removed from the truth. Functional languages are extremely expressive. In a functional language one does not need design patterns because the language is likely so high level, you end up programming in concepts that eliminate design patterns all together. Once such pattern is an Adapter pattern (how is it different from Facade again? Sounds like somebody needed to fill more pages to satisfy their contract). It is eliminated once a language supports a technique called currying. Adapter pattern is best known when applied to the &quot;default&quot; abstraction unit in Java - a class. In functional languages the pattern is applied to functions. The pattern takes an interface and transforms it to another interface someone else expects. Here's an example of an adapter pattern: int pow(int i, int j); int square(int i) { return pow(i, 2); } The code above adapts an interface of a function that raises an integer to an integer power to an interface of a function that squares an integer. In academic circles this trivial technique is called currying (after a logician Haskell Curry who performed mathematical acrobatics necessary to formalize it). Because in FP functions (as opposed to classes) are passed around as arguments, currying is used very often to adapt functions to an interface that someone else expects. Since the interface to functions is its arguments, currying is used to reduce the number of arguments (like in the example above). Functional languages come with this technique built in. You don't need to manually create a function that wraps the original, functional languages will do that for you. As usual, let's extend our language to support this technique. square = int pow(int i, 2); <p>This will automatically create a function <em>square</em> for us with one argument. It will call <em>pow</em> function with the second argument set to <em>2</em>. This will get compiled to the following Java code:</p> class square_function_t { int square(int i) { return pow(i, 2); } } square_function_t square = new square_function_t(); As you can see, we've simply created a wrapper for the original function. In FP currying is just that - a shortcut to quickly and easily create wrappers. You concentrate on your task, and the compiler writes the appropriate code for you! When do you use currying? This should be easy. Any time you'd like to use an adapter pattern (a wrapper). Lazy Evaluation Lazy (or delayed) evaluation is an interesting technique that becomes possible once we adopt a functional philosophy. We've already seen the following piece of code when we were talking about concurrency: String s1 = somewhatLongOperation1(); String s2 = somewhatLongOperation2(); String s3 = concatenate(s1, s2); In an imperative language the order of evaluation would be clear. Because each function may affect or depend on an external state it would be necessary to execute them in order: first somewhatLongOperation1, then somewhatLongOperation2, followed by concatenate. Not so in functional languages. As we saw earlier somewhatLongOperation1 and somewhatLongOperation2 can be executed concurrently because we're guaranteed no function affects or depends on global state. But what if we don't want to run the two concurrently, do we need to run them in order? The answer is no. We only need to run these operations when another function depends on s1 and s2. We don't even have to run them before concatenate is called - we can delay their evaluation until they're required within concatenate. If we replace concatenate with a function that has a conditional and uses only one of its two parameters we may never evaluate one of the parameters at all! Haskell is an example of a delayed evaluation language. In Haskell you are not guaranteed that anything will be executed in order (or at all) because Haskell only executes code when it's required. Lazy evaluation has numerous advantages as well as disadvantages. We will discuss the advantages here and will explain how to counter the disadvantages in the next section. Optimization Lazy evaluation provides a tremendous potential for optimizations. A lazy compiler thinks of functional code exactly as mathematicians think of an algebra expression - it can cancel things out and completely prevent execution, rearrange pieces of code for higher efficiency, even arrange code in a way that reduces errors, all guaranteeing optimizations won't break the code. This is the biggest benefit of representing programs strictly using formal primitives - code adheres to mathematical laws and can be reasoned about mathematically. Abstracting Control Structures Lazy evaluation provides a higher order of abstraction that allows implementing things in a way that would otherwise be impossible. For example consider implementing the following control structure: unless(stock.isEuropean()) { sendToSEC(stock); } We want sendToSEC executed unless the stock is European. How can we implement unless? Without lazy evaluation we'd need some form of a macro system, but in a language like Haskell that's unnecessary. We can implement unless as a function! void unless(boolean condition, List code) { if(!condition) code; } Note that code is never evaluated if the condition is true. We cannot reproduce this behavior in a strict language because the arguments would be evaluated before unless is entered. Infinite Data Structures Lazy languages allow for definition of infinite data structures, something that's much more complicated in a strict language. For example, consider a list with Fibonacci numbers. We clearly can't compute and infinite list in a reasonable amount of time or store it in memory. In strict languages like Java we simply define a Fibonacci function that returns a particular member from the sequence. In a language like Haskell we can abstract it further and simply define an infinite list of Fibonacci numbers. Because the language is lazy, only the necessary parts of the list that are actually used by the program are ever evaluated. This allows for abstracting a lot of problems and looking at them from a higher level (for example, we can use list processing functions on an infinite list). Disadvantages Of course there ain't no such thing as a free lunch(tm). Lazy evaluation comes with a number of disadvantages. Mainly that it is, well, lazy. Many real world problems require strict evaluation. For example consider the following: System.out.println(&quot;Please enter your name: &quot;); System.in.readLine(); In a lazy language you have no guarantee that the first line will be executed before the second! This means we can't do IO, can't use native functions in any meaningful way (because they need to be called in order since they depend on side effects), and can't interact with the outside world! If we were to introduce primitives that allow ordered code execution we'd lose the benefits of reasoning about our code mathematically (which would take all of the benefits of functional programming with it). Fortunately not all is lost. Mathematicians got to work and developed a number of tricks to ensure code gets executed in particular order in a functional setting. We get the best of both worlds! These techniques include continuations, monads, and uniqueness typing. In this article we'll only deal with continuations. We'll leave monads and uniqueness typing for another time. Interestingly, continuations are useful for many things other than enforcing a particular order of evaluation. We'll talk about that as well. Continuations Continuations to programming are what Da Vinci Code is to human history: an amazing revelation of the greatest cover-up known to man. Well, may be not, but they're certainly revealing of deceit in the same sense as square roots of negative numbers. When we learned about functions we only learned half truths based on a faulty assumption that functions must return their value to the original caller. In this sense continuations are a generalization of functions. A function must not necessarily return to its caller and may return to any part of the program. A &quot;continuation&quot; is a parameter we may choose to pass to our function that specifies where the function should return. The description may be more complicated than it sounds. Take a look at the following code: int i = add(5, 10); int j = square(i); The function add returns 15 to be assigned to i, the place where add was originally called. After that the value of i is used to call square. Note that a lazy compiler can't rearrange these lines of code because the second line depends on successful evaluation of the first. We can rewrite this code block using Continuation Passing Style or CPS, where the function add doesn't return to the original caller but instead returns its result to square. int j = add(5, 10, square); In this case add gets another parameter - a function that add must call with its result upon completion. In this case square is a continuation of add. In both cases j will equal 225. Here lays the first trick to force a lazy language to evaluate two expressions in order. Consider the following (familiar) IO code: System.out.println(&quot;Please enter your name: &quot;); System.in.readLine(); The two lines don't depend on each other and the compiler is free to rearrange them as it wishes. However, if we rewrite this code in CPS, there will be a dependency and the compiler will be forced to evaluate the two lines in order! System.out.println(&quot;Please enter your name: &quot;, System.in.readLine); In this case println needs to call readLine with its result and return the result of readLine. This allows us to ensure that the two lines are executed in order and that readLine is evaluated at all (because the whole computation expects the last value as a result). In case of Java println returns void but if it were to return an abstract value (that readLine would accept), we'd solve our problem! Of course chaining function calls like that will quickly become unreadable, but it isn't necessary. We could add syntactic sugar to the language that will allow us to simply type expressions in order, and the compiler would chain the calls for us automatically. We can now evaluate expressions in any order we wish without losing any of the benefits of FP (including the ability to reason about our programs mathematically)! If this is still confusing, remember that a function is just an instance of a class with one member. Rewrite above two lines so that println and readLine are instances of classes and everything will become clear. I would now wrap up this section, except that we've only scratched the surface of continuations and their usefulness. We can write entire programs in CPS, where every function takes an extra continuation argument and passes the result to it. We can also convert any program to CPS simply by treating functions as special cases of continuations (functions that always return to their caller). This conversion is trivial to do automatically (in fact, many compilers do just that). Once we convert a program to CPS it becomes clear that every instruction has some continuation, a function it will call with the result, which in a regular program would be a place it must return to. Let's pick any instruction from above code, say add(5, 10). In a program written in CPS style it's clear what add's continuation is - it's a function that add calls once it's done. But what is it in a non-CPS program? We could, of course, convert the program to CPS, but do we have to? It turns out that we don't. Look carefully at our CPS conversion. If you try to write a compiler for it and think about it long enough you'll realize that the CPS version needs no stack! No function ever &quot;returns&quot; in the traditional sense, it just calls another function with the result instead. We don't need to push function arguments on the stack with every call and then pop them back, we can simply store them in some block of memory and use a jump instruction instead. We'll never need the original arguments - they'll never be used again since no function ever returns! So, programs written in CPS style have no stack but have an extra argument with a function to call. Programs not written in CPS style have no argument with a function to call, but have the stack instead. What does the stack contain? Simply the arguments, and a pointer to memory where the function should return. Do you see a light bulb? The stack simply contains continuation information! The pointer to the return instruction in the stack is essentially the same thing as the function to call in CPS programs! If you wanted to find out what continuation for add(5, 10) is, you'd simply have to examine the stack at the point of its execution! So that was easy. A continuation and a pointer to the return instruction in the stack are really the same thing, only a continuation is passed explicitly, so that it doesn't need to be the same place where the function was called from. If you remember that a continuation is a function, and a function in our language is compiled to an instance of a class, you'll realize that a pointer to the return instruction in the stack and the continuation argument are really the same thing, since our function (just like an instance of a class) is simply a pointer. This means that at any given point in time in your program you can ask for a current continuation (which is simply the information on the stack). Ok, so we know what a current continuation is. What does it mean? When we get a current continuation and store it somewhere, we end up storing the current state of our program - freezing it in time. This is similar to an OS putting itself into hibernation. A continuation object contains the information necessary to restart the program from the point where the continuation object was acquired. An operating system does this to your program all the time when it context switches between the threads. The only difference is that it keeps all the control. If you ask for a continuation object (in Scheme this is done by calling call-with-current-continuation function) you'll get an object that contains the current continuation - the stack (or in a CPS case the function to call next). You can store this object in a variable (or alternatively, on disk). When you choose to &quot;restart&quot; your program with this continuation object you will &quot;transform&quot; to the state of the program when you grabbed the continuation object. It's the same thing as switching back to a suspended thread or waking up an OS from hibernation, except you can do it again and again. When an OS wakes up, the hibernation information is destroyed. If it wasn't, you'd be able to wake up from the same point over and over again, almost like going back in time. You have that control with continuations! In what situations are continuations useful? Usually when you're trying to simulate state in an application of inherently stateless nature to ease your life. A great application of continuations are web applications. Microsoft's ASP.NET goes to tremendous lengths to try and simulate state so that you can write your application with less hassle. If C# supported continuations half of ASP.NET's complexity would disappear - you'd simply store a continuation and restart it when a user makes the web request again. To a programmer of the web application there would be no interruption - the program would simply start from the next line! Continuations are an incredibly useful abstraction for some problems. Considering that many of the traditional fat clients are moving to the web, continuations will become more and more important in the future. <h2><a id=&quot;part_10&quot;>Pattern Matching</a></h2> Pattern matching is not a new or innovative feature. In fact, it has little to do with functional programming. The only reason why it's usually attributed to FP is that functional languages have had pattern matching for some time, while modern imperative languages still don't. Let's dive into pattern matching with an example. Here's a Fibonacci function in Java: int fib(int n) { if(n == 0) return 1; if(n == 1) return 1; return fib(n - 2) + fib(n - 1); } And here's an example of a Fibonacci function in our Java-derived language that supports pattern matching: int fib(0) { return 1; } int fib(1) { return 1; } int fib(int n) { return fib(n - 2) + fib(n - 1); } What's the difference? The compiler implements branching for us. What's the big deal? There isn't any. Someone noticed that a large number of functions contain very complicated switch statements (this is particularly true about functional programs) and decided that it's a good idea to abstract that away. We split the function definition into multiple ones, and put patterns in place of some arguments (sort of like overloading). When the function is called, the compiler compares the arguments with the definitions at runtime, and picks the correct one. This is usually done by picking the most specific definition available. For example, int fib(int n) can be called with n equal to 1, but it isn't because int fib(1) is more specific. Pattern matching is usually more complex than our example reveals. For example, an advanced pattern matching system will allow us to do the following: int f(int n < 10) { ... } int f(int n) { ... } When is pattern matching useful? In a surprisingly large number of cases! Every time you have a complex structure of nested ifs, pattern matching can do a better job with less code on your part. A good function that comes to mind is a standard WndProc function that all Win32 applications must provide (even though it's often abstracted away). Usually a pattern matching system can examine collections as well as simple values. For example, if you pass an array to your function you could pick out all arrays in which the first element is equal to 1 and the third element is greater than 3. Another benefit of pattern matching is that if you need to add or modify conditions, you don't have to go into one huge function. You simply add (or modify) appropriate definitions. This eliminates the need for a whole range of design patterns from the GoF book. The more complex your conditions are, the more pattern matching will help you. Once you're used to it, you start wondering how you ever got through your day without it. Closures So far we've discussed features in the context of &quot;pure&quot; functional languages - languages that are implementations of lambda calculus and don't include features that conflict with Church's formalism. However, many of the features of functional languages are useful outside of lambda calculus framework. While an implementation of an axiomatic system is useful because it allows thinking about programs in terms of mathematical expressions, it may or may not always be practical. Many languages choose to incorporate functional elements without strictly adhering to functional doctrine. Many such languages (like Common Lisp) don't require variables to be final - you can modify things in place. They also don't require functions to depend only on their arguments - functions are allowed to access state outside of their boundaries. But they do include functional features - like higher order functions. Passing functions around in impure languages is a little bit different than doing it in the confines of lambda calculus and requires support for an interesting feature often referred to as lexical closure. Let's take a look at some sample code. Remember, in this case variables aren't final and functions can refer to variables outside of their scope: Function makePowerFn(int power) { int powerFn(int base) { return pow(base, power); } return powerFn; } Function square = makePowerFn(2); square(3); // returns 9 The function make-power-fn returns a function that takes a single argument and raises it to a certain power. What happens when we try to evaluate square(3)? The variable power isn't anywhere in scope of powerFn because makePowerFn has returned and its stack is long gone. How can square work, then? The language must, somehow, store the value of power somewhere for square to work. What if we create another function, cube, that raises something to the third power? The runtime must now store two copies of power, one for each function we generated using make-power-fn. The phenomenon of storing these values is called a closure. Closures don't only store arguments of a host function. For example, a closure can look like this: Function makeIncrementer() { int n = 0; int increment() { return ++n; } } Function inc1 = makeIncrementer(); Function inc2 = makeIncrementer(); inc1(); // returns 1; inc1(); // returns 2; inc1(); // returns 3; inc2(); // returns 1; inc2(); // returns 2; inc2(); // returns 3; The runtime manages to store n, so incrementers can access it. Furthermore, it stores various copies, one for each incrementer, even though they're supposed to disappear when makeIncrementer returns. What does this code compile to? How do closures work behind the scenes? Fortunately, we have a back stage pass. A little common sense goes a long way. The first observation is that local variables are no longer limited to simple scope rules and have an undefined lifetime. The obvious conclusion is that they're no longer stored on the stack - they must be stored on the heap instead8. A closure, then, is implemented just like a function we discussed earlier, except that it has an additional reference to the surrounding variables: class some_function_t { SymbolTable parentScope; // ... } When a closure references a variable that's not in its local scope, it consults this reference for a parent scope. That's it! Closures bring functional and OO worlds closer together. Every time you create a class that holds some state and pass it to somewhere else, think of closures. A closure is just an object that creates &quot;member variables&quot; on the fly by grabbing them from the scope, so you don't have to! What's next? This article only scratches the surface of functional programming. Sometimes a small scratch can progress to something bigger and in our case it's a good thing. In the future I plan to write about category theory, monads, functional data structures, type systems in functional languages, functional concurrency, functional databases and much more. If I get to write (and in the process learn) about half of these topics my life will be complete. In the meantime, Google is our friend. Comments? If you have any questions, comments, or suggestions, please drop a note at coffeemug@gmail.com. I'll be glad to hear your feedback. 1When I was looking for a job in the fall of 2005 I often did ask this question. It's quite amusing how many blank stares I got. You would think that at about $300,000 a piece these people would at least have a good understanding of most tools available to them. 2This appears to be a controversial question. Physicists and mathematicians are forced to acknowledge that it isn't at all clear whether everything in the universe obeys the laws that can be described by mathematics. 3I've always hated history lessons that offer a dry chronology of dates, names, and events. To me history is about the lives of people who changed the world. It is about their private reasons behind their actions, and the mechanisms by which they affected millions of souls. For this reason this history section is hopelessly incomplete. Only very relevant people and events are discussed. 4When I was learning about functional programming I was very annoyed by the term &quot;lambda&quot; because I couldn't really understand what it really means. In this context lambda is a function, the single Greek letter was just easier to write in a mathematical notation. Every time you hear &quot;lambda&quot; when talking about functional programming just translate it in your mind to &quot;function&quot;. 5Interestingly Java strings are immutable anyway. It's rather interesting to explore the reasons for this treachery, but that would distract us from our goal. 6Most functional language compilers optimize recursive functions by transforming them to their iterative alternatives whenever possible. This is called a tail call optimization. 7The opposite isn't always true. While it is sometimes possible to prove that two pieces of code are equivalent, it isn't possible in all situations. 8This is actually no slower than storing on the stack because once you introduce a garbage collector, memory allocation becomes an O(1) operation." property=og:description>
<meta content>
<link rel=canonical href=https://www.defmacro.org/2006/06/19/fp.html>
<meta property=og:url content=/2006/06/19/fp.html>
<meta property=og:site_name content=defmacro>
<meta property=og:type content=article>
<meta property=article:published_time content=2006-06-19T00:00:00+00:00>
<meta name=twitter:card content=summary>
<meta property=twitter:title content="Functional Programming For The Rest of Us">
<style>body,h1,h2,h3,p,pre,hr,ul{margin:0;padding:0}body{font:400 16px/1.5 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";color:#111;background-color:#fdfdfd;-webkit-text-size-adjust:100%;-webkit-font-feature-settings:"kern"1;-moz-font-feature-settings:"kern"1;-o-font-feature-settings:"kern"1;font-feature-settings:"kern"1;font-kerning:normal;display:flex;min-height:100vh;flex-direction:column}h1,h2,h3,p,pre,ul{margin-bottom:15px}main{display:block}h1,h2{font-weight:400}a{color:#2a7ae2;text-decoration:none}a:visited{color:#1756a9}a:hover{color:#111;text-decoration:underline}.social-media-list a:hover{text-decoration:none}.social-media-list a:hover .username{text-decoration:underline}pre{font-size:15px;border:1px solid #e8e8e8;border-radius:3px;background-color:#eef}pre{padding:8px 12px;overflow-x:auto}.wrapper{max-width:-webkit-calc(800px - (30px*2));max-width:calc(800px - (30px*2));margin-right:auto;margin-left:auto;padding-right:30px;padding-left:30px}@media screen and (max-width:800px){.wrapper{max-width:-webkit-calc(800px - (30px));max-width:calc(800px - (30px));padding-right:15px;padding-left:15px}}.wrapper:after,.footer-col-wrapper:after{content:"";display:table;clear:both}.social-media-list li+li{padding-top:5px}.site-header{border-top:5px solid #424242;border-bottom:1px solid #e8e8e8;min-height:55.95px;position:relative}.site-title{font-size:26px;font-weight:300;line-height:54px;letter-spacing:-1px;margin-bottom:0;float:left}.site-title,.site-title:visited{color:#424242}.site-nav{float:right;line-height:54px}@media screen and (max-width:600px){.site-nav{position:absolute;top:9px;right:15px;background-color:#fdfdfd;border:1px solid #e8e8e8;border-radius:5px;text-align:right}.site-nav .menu-icon>svg{fill:#424242}}.site-footer{border-top:1px solid #e8e8e8;padding:30px 0}.social-media-list{list-style:none;margin-left:0}.footer-col-wrapper{font-size:15px;color:#828282;margin-left:-15px}.footer-col{float:left;margin-bottom:15px;padding-left:15px}.footer-col-1{width:-webkit-calc(35% - (30px/2));width:calc(35% - (30px/2))}@media screen and (max-width:800px){.footer-col-1{width:-webkit-calc(50% - (30px/2));width:calc(50% - (30px/2))}}@media screen and (max-width:600px){.footer-col{float:none;width:-webkit-calc(100% - (30px/2));width:calc(100% - (30px/2))}}.page-content{padding:30px 0;flex:1}.post-meta{font-size:14px;color:#828282}.post-header{margin-bottom:30px}.post-title{font-size:42px;letter-spacing:-1px}@media screen and (max-width:800px){.post-title{font-size:36px}}.post-content{margin-bottom:30px}.post-content h2{font-size:32px}@media screen and (max-width:800px){.post-content h2{font-size:28px}}.post-content h3{font-size:26px}@media screen and (max-width:800px){.post-content h3{font-size:22px}}hr{margin-top:2em;margin-bottom:2em}.post-title{line-height:1.2}h2>a,h2>a:hover,div#footnotes>p>sup>a{color:#111;text-decoration:none}div#footnotes>p{font-style:italic}.post-content h3{font:14px/20px Verdana,sans-serif;font-weight:bold;text-align:center}ul.social-media-list>li{padding-bottom:5px}</style><link type=application/atom+xml rel=alternate href=https://www.defmacro.org/feed.xml title=defmacro><link type=image/x-icon rel="shortcut icon" href="data:image/vnd.microsoft.icon;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAAAAAByaaZbAAAM3mlDQ1BJQ0MgUHJvZmlsZQAAWIWlVwdYU8kWnluS0BJ6lRI60gwoXUqkBpBeBFGJIZBACDEFAbEhiyu4dhHBsqKiKIsdgcWGBQtrB7sLuigo6+IqNixvEopYdt/7vnfzzb3/nXPOnDpnbgBQ5TAFAh4KAMjki4WBUfSEKQmJVNJdIAe0gTKwB8pMlkhAj4gIhSyAn8Vng2+uV+0AkT6v2UnX+pb+rxchhS1iwedxOHJTRKxMAJCJAJC6WQKhGAB5MzhvOlsskOIgiDUyYqJ8IU4CQE5pSFZ6GQWy+Wwhl0UNFDJzqYHMzEwm1dHekRohzErl8r5j9f97ZfIkI7rhUBJlRIfApz20vzCF6SfFrhDvZzH9o4fwk2xuXBjEPgCgJgLxpCiIgyGeKcmIpUNsC3FNqjAgFmIviG9yJEFSPAEATCuPExMPsSHEwfyZYeEQu0PMYYl8EyG2griSw2ZI8wRjhp3nihkxEEN92DNhVpSU3xoAfGIK289/cB5PzcgKkdpgAvFBUXa0/7DNeRzfsEFdeHs6MzgCYguIX7J5gVGD6xD0BOII6ZrwneDH54WFDvpFKGWLZP7Cd0K7mBMjzZkjAEQTsTAmatA2YkwqN4ABcQDEORxhUNSgv8SjAp6szmBMiO+FkqjYQR9JAWx+rHRNaV0sYAr9AwdjRWoCcQgTsEEWmAnvLMAHnYAKRIALsmUoDTBBJhxUaIEtHIGQiw+HEHKIQIaMQwi6RujDElIZAaRkgVTIyYNyw7NUkALlB+Wka2TBIX2Trtstm2MN6bOHw9dwO5DANw7ohXQORJNBh2wmB9qXCZ++cFYCaWkQj9YyKB8hs3XQBuqQ9T1DWrJktjBH5D7b5gvpfJAHZ0TDnuHaOA0fD4cHHop74jSZlBBy5AI72fxE2dyw1s+eS33rGdE6C9o62vvR8RqO4QkoJYbvPOghfyg+ImjNeyiTMST9lZ8r9CRWAkHpskjG9KoRK6gFwhlc1qXlff+StW+1232Rt/DRdSGrlJRv6gLqIlwlXCbcJ1wHVPj8g9BG6IboDuEu/N36blSyRmKQBkfWSAWwv8gNG3LyZFq+tfNzzgbX+WoFBBvhpMtWkVIz4eDKeEQj+ZNALIb3VJm03Ve5C/xab0t+kw6gti89fg5Qa1Qazn6Odhten3RNqSU/lb9CTyCYXpU/wBZ8pkrzwF4c9ioMFNjS9tJ6adtoNbQXtPufOWg3aH/S2mhbIOUptho7hB3BGrBGrBVQ4VsjdgJrkKEarAn+9v1Dhad9p8KlFcMaqmgpVTxUU6Nrf3Rk6aOiJeUfjnD6P9Tr6IqRZux/s2j0Ol92BPbnXUcxpThQSBRrihOFTkEoxvDnSPGByJRiQgmlaENqEMWS4kcZMxKP4VrnDWWY+8X+HrQ4AVKHK4Ev6y5MyCnlYA75+7WP1C+8lHrGHb2rEDLcVdxRPeF7vYj6xc6KhbJcMFsmL5Ltdr5MTvBF/YlkXQjOIFNlOfyObbgh7oAzYAcKB1ScjjvhPkN4sCsN9yVZpnBvSPXC/XBXaR/7oi+w/qv1o3cGm+hOtCT6Ey0/04l+xCBiAHw6SOeJ44jBELtJucTsHLH0kPfNEuQKuWkcMZUOv3LYVAafZW9LdaQ5wNNN+s00+CnwIlL2LYRotbIkwuzBOVx6IwAF+D2lAXThqWoKT2s7qNUFeMAz0x+ed+EgBuZ1OvSDA+0Wwsjmg4WgCJSAFWAtKAebwTZQDWrBfnAYNMEeewZcAJdBG7gDz5Mu8BT0gVdgAEEQEkJG1BFdxAgxR2wQR8QV8UL8kVAkCklAkpE0hI9IkHxkEVKCrELKkS1INbIPaUBOIOeQK8gtpBPpQf5G3qEYqoRqoAaoBToOdUXpaAgag05D09BZaB5aiC5Dy9BKtAatQ0+gF9A2tAN9ivZjAFPEtDBjzA5zxXyxcCwRS8WE2DysGCvFKrFa2ANasGtYB9aLvcWJuDpOxe1gFoPwWJyFz8Ln4UvxcnwnXoefwq/hnXgf/pFAJugTbAjuBAZhCiGNMJtQRCglVBEOEU7DDt1FeEUkErVgflxg3hKI6cQ5xKXEjcQ9xOPEK8SHxH4SiaRLsiF5ksJJTJKYVERaT6ohHSNdJXWR3sgpyhnJOcoFyCXK8eUK5Erldskdlbsq91huQF5F3lzeXT5cPkU+V365/Db5RvlL8l3yAwqqCpYKngoxCukKCxXKFGoVTivcVXihqKhoouimGKnIVVygWKa4V/GsYqfiWyU1JWslX6UkJYnSMqUdSseVbim9IJPJFmQfciJZTF5GriafJN8nv6GoU+wpDEoKZT6lglJHuUp5piyvbK5MV56unKdcqnxA+ZJyr4q8ioWKrwpTZZ5KhUqDyg2VflV1VQfVcNVM1aWqu1TPqXarkdQs1PzVUtQK1baqnVR7qI6pm6r7qrPUF6lvUz+t3qVB1LDUYGika5Ro/KJxUaNPU01zgmacZo5mheYRzQ4tTMtCi6HF01qutV+rXeudtoE2XZutvUS7Vvuq9mudMTo+OmydYp09Om0673Spuv66GbordQ/r3tPD9az1IvVm623SO63XO0ZjjMcY1pjiMfvH3NZH9a31o/Tn6G/Vb9XvNzA0CDQQGKw3OGnQa6hl6GOYbrjG8Khhj5G6kZcR12iN0TGjJ1RNKp3Ko5ZRT1H7jPWNg4wlxluMLxoPmFiaxJoUmOwxuWeqYOpqmmq6xrTZtM/MyGyyWb7ZbrPb5vLmruYc83XmLeavLSwt4i0WWxy26LbUsWRY5lnutrxrRbbytpplVWl1fSxxrOvYjLEbx162Rq2drDnWFdaXbFAbZxuuzUabK7YEWzdbvm2l7Q07JTu6XbbdbrtOey37UPsC+8P2z8aZjUsct3Jcy7iPNCcaD55udxzUHIIdChwaHf52tHZkOVY4Xh9PHh8wfv74+vHPJ9hMYE/YNOGmk7rTZKfFTs1OH5xdnIXOtc49LmYuyS4bXG64arhGuC51PetGcJvkNt+tye2tu7O72H2/+18edh4ZHrs8uidaTmRP3DbxoaeJJ9Nzi2eHF9Ur2etnrw5vY2+md6X3Ax9TnxSfKp/H9LH0dHoN/dkk2iThpEOTXvu6+871Pe6H+QX6Fftd9Ffzj/Uv978fYBKQFrA7oC/QKXBO4PEgQlBI0MqgGwwDBotRzegLdgmeG3wqRCkkOqQ85EGodagwtHEyOjl48urJd8PMw/hhh8NBOCN8dfi9CMuIWRG/RhIjIyIrIh9FOUTlR7VEq0fPiN4V/SpmUszymDuxVrGS2OY45bikuOq41/F+8aviO6aMmzJ3yoUEvQRuQn0iKTEusSqxf6r/1LVTu5KckoqS2qdZTsuZdm663nTe9CMzlGcwZxxIJiTHJ+9Kfs8MZ1Yy+2cyZm6Y2cfyZa1jPU3xSVmT0sP2ZK9iP071TF2V2p3mmbY6rYfjzSnl9HJ9ueXc5+lB6ZvTX2eEZ+zI+MSL5+3JlMtMzmzgq/Ez+KeyDLNysq4IbARFgo5Z7rPWzuoThgirRIhomqherAH/YLZKrCQ/SDqzvbIrst/Mjpt9IEc1h5/TmmuduyT3cV5A3vY5+BzWnOZ84/yF+Z1z6XO3zEPmzZzXPN90fuH8rgWBC3YuVFiYsfC3AlrBqoKXi+IXNRYaFC4ofPhD4A+7iyhFwqIbiz0Wb/4R/5H748Ul45esX/KxOKX4fAmtpLTk/VLW0vM/OfxU9tOnZanLLi53Xr5pBXEFf0X7Su+VO1eprspb9XD15NV1a6hrite8XDtj7bnSCaWb1ymsk6zrKAstq19vtn7F+vflnPK2ikkVezbob1iy4fXGlI1XN/lsqt1ssLlk87ufuT/f3BK4pa7SorJ0K3Fr9tZH2+K2tWx33V5dpVdVUvVhB39Hx86onaeqXaqrd+nvWr4b3S3Z3VOTVHP5F79f6mvtarfs0dpTshfslex9si95X/v+kP3NB1wP1B40P7jhkPqh4jqkLreu7zDncEd9Qv2VhuCG5kaPxkO/2v+6o8m4qeKI5pHlRxWOFh79dCzvWP9xwfHeE2knHjbPaL5zcsrJ66ciT108HXL67JmAMydb6C3HznqebTrnfq7hvOv5wxecL9S1OrUe+s3pt0MXnS/WXXK5VH/Z7XLjlYlXjl71vnrimt+1M9cZ1y+0hbVdaY9tv3kj6UbHzZSb3bd4t57fzr49cGcB/Igvvqdyr/S+/v3K38f+vqfDueNIp19n64PoB3cesh4+/UP0x/uuwkfkR6WPjR5Xdzt2N/UE9Fx+MvVJ11PB04Heoj9V/9zwzOrZwb98/mrtm9LX9Vz4/NPfS1/ovtjxcsLL5v6I/vuvMl8NvC5+o/tm51vXty3v4t89Hpj9nvS+7MPYD40fQz7e/ZT56dN/AC1d8Bx8dIG+AAAACXBIWXMAAAsTAAALEwEAmpwYAAABWWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgpMwidZAAAFe0lEQVRIDYVWS2xUZRT+/v/+/507M6VP++5g2oIiqEUxkcS48wViogkJCUjShBAfWxIXhgXGblywJLIHMTQkhKQJqUJxYSgYa+vCtlqkQt8tnXZo53GfxzNzp+1MF3ommbnn/I/z+s53RwxUSDtCrvYJhrL1/MqLjqeUAoRjS2n+UZXISO1I4QsyfV9klPWytk3DFkYgPO2b44+6PM/KpjKIV8a8wFxqeiknIp6nA+kaQni/8VUyCkQAAwoSMIXWEz/23cShI2/v5kWFiCD2aPCHhAdlEAKBopAAAfePTrN+82bbtdch2UKCjSwEQYYUGpv7Q+vvB6fb45YVb58++DsCtm2sCwEtpJ83bUkQzV5C52Q6l0tPduJSNlq+LAMpOO4SIevhd5gLDXP4/qEVRrOxwyVJ3oZS+JX+3HxTNjTlGmcX/Y14QpOWUpf7BFzo4q2BCYfjLpWAPehSA3z1DJ5yrfNipFFRyDpU8998oDwidtDyQaou3FGXfHcnlefAIZW7hJFtfR+61uD7ayP4KJEteis6cYJ847hdmyJ8HJv8BtUxkUkmzxzjjEqEhKGV56l8dzeEu1r9xY6zq6ts6PmsmrjopaueqyyrrBARJVD75YfDs0ZT1z4BYWrG0JZoQ81EigHlYUTm5FSb75iVb7ha0QNP6MkUR0WBEBRIg0SwqFYXlFM4Ujig51PTXLcAOuD6CNJLmOdEKwjas3NC+Cn13GslKQMts29uBZB/aunkmsw8TsXr9vIYYEi5OWtrB0nXK00SwnUgVq/29QENJ092gXxpyiLaw2NlFQhNyZ5P+yp2ti6e338fji8DtYn3LU8lT4q+PZ9ozD2ejXXi6AMz2D4PJVsLj2SNnkV6gQPN/N0+/UPOkmrbPJS0qXDCG0Z1KrxmEX2rWlJZ87c7gHZnEfNDs4+bmTxPlMn2pANtlOeYJ4H/Es9oRroIDgOHYvi/pAW6sFoVXtmAI9VungS251nqUdh7v0a80YCs6Jxse8eyFdxSNDJrlW5nTvLE56vnURu3F9dxbZcjlCHLktq2P89itV/tvt6fxL73GBpSKWGWHBAwy89DaVD8k8OP1iPNzzL4hFJ/rijmAuZMn0mNzH/mGdsclw48wUOgf62fcwMjakVpbchm0p9XVa2ShAXb0PAcimSRsKEsz+X62zxA9Y0tttBS5MiCw0DKqYY9PA/TQw/duj2vxDjhaAdP8SiPaHPXXl6Za2E9MzK2GOk80M7LGQymye1NFEpzfJxodCCg5Z6wUj3LFNweJRo7UdATvQ45g7hv+1f4hdLU2gAcHKexW7RyBqhuaa0BzqzQrVEa6+LpaW0ygcu+exd3g0GIRtbEjp04nn5why6iLSSyBC7SwET6OHbu4ODMRolBuietp/1oWnA48LUVXBmR0anrcJKMTz9p4/pUzBi5gpU1bo+z0Ij+lCnV2g0U8b7egDEhH/XXLoc5LNf1z5oYQ8N6qKdwY11Jyg5vMDSZeOLKdcQ38B/nq3KLW/SP4XThHbfZah+mr2KbL0nhMpjNWBk4PUnxbhRHwkyiw3TrGmfyBMQSnWtqJqMdy1ySvJjoZrLNVR1GfWiosRMHRLbjYzSHejNOdNjBqwmbK5yXehyucXCXlk5hV6VlxZoFemn8Fo0A4WsXGKFb49QL2RyzrMpOnH7i/4xBh6ZOhTfgikujt4nutYZ62z0i7rRzubh8epoy9/FLlmjpajew/9yg59H4ABH9deEwcOjCBD/eYbj4g+f2A929T4hyQ+Le/ohjBkspxCsqXSc+PvOWI9V60kWs2uIB/qnlhayhn65lUF1j5Cx3WAxEZUBaC+V7OZLWTOp5CjyT+Yr//pieMcF/fwJhKR4Rx5ESmX8BK9Joc+H3tHUAAAAASUVORK5CYII=" data-sf-original-href=https://www.defmacro.org/favicon.ico><style>.sf-hidden{display:none !important}</style><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:; frame-src 'self' data:;"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style></head>
<body><header class=site-header role=banner translate=no>
 <div class=wrapper>
 <a class=site-title href=https://www.defmacro.org/>defmacro</a>
 <nav class=site-nav>
 <span class="menu-icon sf-hidden">
 <svg viewBox="0 0 18 15" width=18px height=15px>
 <path fill=#424242 d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
 <path fill=#424242 d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
 <path fill=#424242 d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
 </svg>
 </span>
 <div class=trigger>
 
 
 
 
 
 
 
 </div>
 </nav>
 </div>
 <div style=background-color:#f9f3db>
 <p style=padding:1em;text-align:center>
 I now write regularly at <a href=https://www.spakhm.com/>www.spakhm.com</a>. Everything new is there!
 </p>
 <div>
</div></div></header>
<main class=page-content aria-label=Content>
 <div class=wrapper>
 <style data-id=immersive-translate-default-injected-css class=sf-hidden>:root{--immersive-translate-theme-underline-borderColor:#72ece9;--immersive-translate-theme-nativeUnderline-borderColor:#72ece9;--immersive-translate-theme-nativeDashed-borderColor:#72ece9;--immersive-translate-theme-nativeDotted-borderColor:#72ece9;--immersive-translate-theme-highlight-backgroundColor:#ff0;--immersive-translate-theme-dashed-borderColor:#59c1bd;--immersive-translate-theme-blockquote-borderColor:#c35;--immersive-translate-theme-thinDashed-borderColor:#ff374f;--immersive-translate-theme-dashedBorder-borderColor:#94a3b8;--immersive-translate-theme-dashedBorder-borderRadius:0;--immersive-translate-theme-solidBorder-borderColor:#94a3b8;--immersive-translate-theme-solidBorder-borderRadius:0;--immersive-translate-theme-dotted-borderColor:#94a3b8;--immersive-translate-theme-wavy-borderColor:#72ece9;--immersive-translate-theme-dividingLine-borderColor:#94a3b8;--immersive-translate-theme-grey-textColor:#2f4f4f;--immersive-translate-theme-marker-backgroundColor:#fbda41;--immersive-translate-theme-marker-backgroundColor-rgb:251,218,65;--immersive-translate-theme-marker2-backgroundColor:#ff0;--immersive-translate-theme-opacity-opacity:10}.immersive-translate-target-translation-block-wrapper{margin:8px 0 !important;display:inline-block}.immersive-translate-target-translation-block-wrapper-theme-dividingLine::before{content:"";display:block;max-width:80px;width:10%;border-top:1px dashed var(--immersive-translate-theme-dividingLine-borderColor);padding-top:8px}.immersive-translate-target-translation-inline-wrapper-theme-dividingLine::before{content:"";border-left:1px dashed var(--immersive-translate-theme-dividingLine-borderColor);max-height:16px;height:16px;padding-left:8px}@-webkit-keyframes immersive-translate-loading-animation{from{-webkit-transform:rotate(0deg)}to{-webkit-transform:rotate(359deg)}}@keyframes immersive-translate-loading-animation{from{transform:rotate(0deg)}to{transform:rotate(359deg)}}</style><style data-id=immersive-translate-user-custom-style class=sf-hidden>:root{--immersive-translate-theme-dividingLine-borderColor:#cf77ff}</style><article class="post h-entry" itemscope itemtype=http://schema.org/BlogPosting>
 <header class=post-header>
 <h1 class="post-title p-name" itemprop="name headline">Functional Programming For The Rest of Us<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>适合我们其他人的函数式编程</font></font></font></h1>
 <p class=post-meta>
 <time class=dt-published datetime=2006-06-19T00:00:00+00:00 itemprop=datePublished>Jun 19, 2006
 <font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>2006 年 6 月 19 日</font></font></font></time></p>
 </header>
 <div class="post-content e-content" itemprop=articleBody>
 <h2><a id=part_1>Introduction<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> 介绍</font></font></font></a></h2>
<p class=first>Programmers are procrastinators. Get in, get some coffee, check the mailbox, read the RSS feeds,
read the news, check out latest articles on techie websites, browse through political discussions on the designated
sections of the programming forums. Rinse and repeat to make sure nothing is missed. Go to lunch. Come back, stare
at the IDE for a few minutes. Check the mailbox. Get some coffee. Before you know it, the day is over.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>程序员都是拖延者。坐进去，喝杯咖啡，检查邮箱，阅读 RSS 提要，阅读新闻，查看技术网站上的最新文章，浏览编程论坛指定部分的政治讨论。冲洗并重复以确保没有遗漏任何东西。去吃午饭。回来，盯着IDE看了几分钟。检查邮箱。喝点咖啡。不知不觉中，这一天就结束了。</font></font></font></p>
<p>The only thing, every once in a while challenging articles actually do pop up. If you're looking at the right
places you'll find at least one of these every couple of days. These articles are hard to get through and take
some time, so they start piling up. Before you know it, you have a list of links and a folder full of PDF files
and you wish you had a year in a small hut in the middle of the forest with nobody around for miles so you could
catch up. Would be nice if someone came in every morning while you're taking a walk down the river to bring some
food and take out the garbage.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>唯一的事情是，每隔一段时间就会出现一些具有挑战性的文章。如果您正在寻找正确的地方，每隔几天您就会至少找到一个这样的地方。这些文章很难读完，而且需要一些时间，所以它们开始堆积起来。在不知不觉中，您已经有了一个链接列表和一个装满 PDF 文件的文件夹，您希望在森林中央的一间小小屋里度过一年，周围几英里内都没有人，这样您就可以赶上。如果每天早上你在河边散步时有人进来带些食物并倒垃圾，那就太好了。</font></font></font></p>
<p>I don't know about your list, but a large chunk of the articles in mine are about functional programming. These
generally are the hardest to get through. Written in a dry academic language, even the "ten year Wall Street industry
veterans" don't understand what functional programming (also referred to as <em>FP</em>) articles are all about. If you ask a project
manager in Citi Group or in Deutsche Bank<sup><a href=#ask-a-manager>1</a></sup> why they chose to use JMS instead
of Erlang they'll say they can't use academic languages for industrial strength applications. The problem is, some of
the most complex systems with the most rigid requirements are written using functional programming
elements. Something doesn't add up.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>我不知道你的列表，但我的大部分文章都是关于函数式编程的。这些通常是最难通过的。用干巴巴的学术语言写的，连“十年华尔街行业老手”都看不懂函数式编程（也称FP）文章到底讲的是什么。如果您询问花旗集团或德意志银行的项目经理 <sup><a href=#ask-a-manager>1</a></sup> 为什么他们选择使用 JMS 而不是 Erlang，他们会说他们不能将学术语言用于工业强度应用程序。问题是，一些具有最严格要求的最复杂的系统是使用函数式编程元素编写的。有些东西没有加起来。</font></font></font></p>
<p>It's true that FP articles and papers are hard to understand, but they don't have to be. The reasons for the
knowledge gap are purely historical. There is nothing inherently hard about FP concepts. Consider this article "an
accessible guide to FP", a bridge from our imperative minds into the world of FP. Grab a coffee and keep on reading.
With any luck your coworkers will start making fun of you for your FP comments in no time.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>FP 的文章和论文确实很难理解，但也不一定如此。知识差距的原因纯粹是历史性的。 FP 概念本质上没有什么难的。将这篇文章视为“FP 的易懂指南”，它是我们从命令式思维进入 FP 世界的桥梁。喝杯咖啡，继续阅读。运气好的话，你的同事很快就会因为你的 FP 评论而开始取笑你。</font></font></font></p>
<p>So what is FP? How did it come about? Is it edible? If it's as useful
as its advocates claim, why isn't it being used more often in the industry? Why is it that only people with PhDs
tend to use it? Most importantly, why is it so damn hard to learn? What is all this closure, continuation, currying,
lazy evaluation and no side effects business? How can it be used in projects that don't involve a university?
Why does it seem to be so different from everything good, and holy, and dear to our imperative hearts? We'll clear
this up very soon. Let's start with explaining the reasons for the huge gap between the real world and academic
articles. The answer is as easy as taking a walk in the park.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>那么什么是 FP 呢？它是怎么发生的？可以吃吗？如果它像其拥护者声称的那样有用，为什么它没有在行业中得到更广泛的使用呢？为什么只有拥有博士学位的人才倾向于使用它？最重要的是，为什么学习这么难？这些闭包、延续、柯里化、惰性求值和无副作用是什么？如何将其用于不涉及大学的项目中？为什么它看起来与我们内心迫切渴望的一切美好、神圣、亲爱的事物如此不同？我们很快就会解决这个问题。我们首先来解释一下现实世界与学术文章之间存在巨大差距的原因。答案就像在公园散步一样简单。</font></font></font></p>
<h2 class=first><a id=part_2>A Walk In The Park<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> 在公园散步</font></font></font></a></h2>
<p class=first>Fire up the time machine. Our walk in the park took place more than two thousand years ago, on a
beautiful sunny day of a long forgotten spring in 380 B.C. Outside the city walls of Athens, under the pleasant shade
of olive trees Plato was walking towards the Academy with a beautiful slave boy. The weather was lovely, the dinner
was filling, and the conversation turned to philosophy.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>启动时光机。我们在公园里的散步发生在两千多年前，那是公元前 380 年一个早已被遗忘的春天，一个阳光明媚的日子。雅典城墙外，在宜人的橄榄树荫下，柏拉图带着一个美丽的奴隶男孩朝学院走去。天气很好，晚餐很丰盛，谈话转向了哲学。</font></font></font></p>
<p>"Look at these two students", said Plato carefully picking words to make the question educational. "Who do you
think is taller?" The slave boy looked towards the basin of water where two men were standing. "They're about
the same height", he said. "What do you mean 'about the same'?", asked Plato. "Well, they look the same from here
but I'm sure if I were to get closer I'd see that there is some difference."<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>“看看这两个学生”，柏拉图小心翼翼地挑选措辞，使这个问题具有教育意义。 “你觉得谁更高？”奴童看向那盆水，那里站着两个人。 “他们的身高差不多”，他说。 “‘大致相同’是什么意思？”柏拉图问道。 “嗯，从这里看它们是一样的，但我确信如果我走近一些，我会发现有一些不同。”</font></font></font></p>
<p>Plato smiled. He was leading the boy in the right direction. "So you would say that there is nothing perfectly
equal in our world?" After some thinking the boy replied: "I don't think so. Everything is at least a little
different, even if we can't see it." The point hit home! "Then if nothing is perfectly equal in this world, how
do you think you understand the concept of 'perfect' equality?" The slave boy looked puzzled. "I don't know",
he replied.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>柏拉图笑了。他正在带领这个男孩走向正确的方向。 “所以你会说我们的世界上没有什么是完全平等的？”想了想，男孩回答道：“我不这么认为。一切至少都有一点不同，即使我们看不到。”重点来了！ “那么，如果这个世界上没有什么是完全平等的，那么你认为你如何理解‘完美’平等的概念呢？”奴童一脸疑惑。 “我不知道”，他回答道。</font></font></font></p>
<p>So was born the first attempt to understand the nature of mathematics. Plato suggested that everything in
our world is just an approximation of perfection. He also realized that we understand the concept of perfection
even though we never encountered it. He came to conclusion that perfect mathematical forms must live in another
world and that we somehow know about them by having a connection to that "alternative" universe. It's fairly
clear that there is no perfect circle that we can observe. But we also understand what a perfect circle is and
can describe it via equations. What is mathematics, then? Why is the universe described with mathematical laws?
Can all of the phenomena of our universe be described by mathematics?<sup><a href=#universe-math>2</a></sup><font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>于是诞生了理解数学本质的第一次尝试。柏拉图认为，我们世界上的一切都只是完美的近似。他还意识到我们理解完美的概念，尽管我们从未遇到过它。他得出的结论是，完美的数学形式必须存在于另一个世界，并且我们通过与那个“替代”宇宙的联系以某种方式了解它们。很明显，我们无法观察到完美的圆。但我们也了解什么是完美的圆，并且可以通过方程来描述它。那么什么是数学呢？为什么宇宙要用数学定律来描述？我们宇宙中的所有现象都可以用数学来描述吗？ <sup><a href=#universe-math>2</a></sup> </font></font></font></p>
<p><a href=http://en.wikipedia.org/wiki/Philosophy_of_mathematics>Philosophy of mathematics</a> is a very
complex subject. Like most philosophical disciplines it is far more adept at posing questions rather than providing
answers. Much of the consensus revolves around the fact that mathematics is really a puzzle: we set up a set of
basic non-conflicting principles and a set of rules on how to operate with these principles. We can then stack
these rules together to come up with more complex rules. Mathematicians call this method a "formal system" or a
"calculus". We can effectively write a formal system for Tetris if we wanted to. In fact, a working implementation of Tetris
<em>is</em> a formal system, just specified using an unusual representation.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>数学哲学是一门非常复杂的学科。像大多数哲学学科一样，它更擅长提出问题而不是提供答案。大多数共识都围绕着这样一个事实：数学确实是一个难题：我们建立了一套基本的、不冲突的原则以及一套关于如何运用这些原则的规则。然后我们可以将这些规则堆叠在一起以得出更复杂的规则。数学家称这种方法为“形式系统”或“微积分”。如果我们愿意的话，我们可以有效地为俄罗斯方块编写一个形式的系统。事实上，俄罗斯方块的有效实现是一个形式的系统，只是使用了一种不寻常的表示形式来指定。</font></font></font></p>
<p>A civilization of furry creatures on Alpha Centauri would not be able to read our formalisms of Tetris
and circles because their only sensory input might be an organ that senses smells. They likely will never find
out about the Tetris formalism, but they very well might have a formalism for circles. We probably wouldn't
be able to read it because our sense of smell isn't that sophisticated, but once you get past the
<em>representation</em> of the formalism (via various sensory instruments and standard code breaking
techniques to understand the <em>language</em>), the concepts underneath are understandable to any
intelligent civilization.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>半人马座阿尔法星上毛茸茸的生物文明将无法解读我们的俄罗斯方块和圆圈的形式，因为它们唯一的感官输入可能是感知气味的器官。他们可能永远不会发现俄罗斯方块的形式论，但他们很可能有圆的形式论。我们可能无法阅读它，因为我们的嗅觉并不那么复杂，但是一旦你超越了形式论的表征（通过各种感官仪器和标准密码破译技术来理解语言），之下的概念任何智慧文明都可以理解。</font></font></font></p>
<p>Interestingly if no intelligent civilization ever existed in the universe the formalisms for Tetris and circles
would still hold water, it's just that nobody would be around to find out about them. If an intelligent
civilization popped up, it would likely discover some formalisms that help describe the laws of our universe.
They also would be very unlikely to ever find out about Tetris because there is nothing in the universe
that resembles it. Tetris is one of countless examples of a formal system, a puzzle, that has nothing to do
with the real world. We can't even be sure that natural numbers have full resemblance to the real world,
after all one can easily think of a number so big that it cannot describe anything in our universe
since it might actually turn out to be finite.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>有趣的是，如果宇宙中不存在智慧文明，俄罗斯方块和圆圈的形式仍然有效，只是没有人会发现它们。如果出现一个智慧文明，它很可能会发现一些有助于描述宇宙规律的形式论。他们也不太可能发现俄罗斯方块，因为宇宙中没有任何东西与它相似。俄罗斯方块是无数形式系统的例子之一，是一个与现实世界无关的谜题。我们甚至不能确定自然数与现实世界完全相似，毕竟人们可以很容易地想到一个如此大的数字，以至于它无法描述我们宇宙中的任何东西，因为它实际上可能是有限的。</font></font></font></p>
<h2><a id=part_3>A Bit of History</a><sup><a href=#history>3</a></sup><font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> 一点历史 <sup><a href=#history>3</a></sup> </font></font></font></h2>
<p class=first>Let's shift gears in our time machine. This time we'll travel a lot closer, to the 1930s.
The Great Depression was ravaging the New and the Old worlds. Almost every family from every social class
was affected by the tremendous economic downturn. Very few sanctuaries remained where people were safe
from the perils of poverty. Few people were fortunate enough to be in these sanctuaries, but they did exist. Our
interest lies in mathematicians in Princeton University.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>让我们的时间机器变速吧。这次我们将走得更近，回到 1930 年代。大萧条正在蹂躏新旧世界。几乎每个社会阶层的每个家庭都受到经济严重衰退的影响。人们免受贫困危险的避难所所剩无几。很少有人有幸进入这些庇护所，但它们确实存在。我们的关注点在于普林斯顿大学的数学家。</font></font></font></p>
<p>The new offices constructed in gothic style gave Princeton an aura of a safe haven. Logicians from all over
the world were invited to Princeton to build out a new department. While most of America couldn't find a piece of
bread for dinner, high ceilings, walls covered with elaborately carved wood, daily discussions by a cup of tea,
and walks in the forest were some of the conditions in Princeton.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>哥特式风格的新办公室给普林斯顿带来了避风港的氛围。来自世界各地的逻辑学家被邀请到普林斯顿建立一个新系。虽然美国大多数人都找不到一块面包当晚餐，但高高的天花板、覆盖着精心雕刻的木头的墙壁、每天喝茶讨论以及在森林里散步都是普林斯顿所能提供的条件的一部分。</font></font></font></p>
<p>One mathematician living in such lavish lifestyle was a young man named Alonzo Church. Alonzo received a B.S.
degree from Princeton and was persuaded to stay for graduate school. Alonzo felt the architecture was fancier than
necessary. He rarely showed up to discuss mathematics with a cup of tea and he didn't enjoy the walks in the woods.
Alonzo was a loner: he was most productive when working on his own. Nevertheless Alonzo had regular contacts with
other Princeton inhabitants. Among them were Alan Turing, John von Neumann, and Kurt Gödel.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>一位生活在如此奢侈生活中的数学家是一位名叫阿隆佐·丘奇的年轻人。阿隆索从普林斯顿大学获得了理学士学位，并被说服留在普林斯顿大学攻读研究生学位。阿朗佐觉得这儿的建筑过于华丽。他很少边喝茶边讨论数学，也不喜欢在树林里散步。阿朗佐是一个独来独往的人：他独自工作时效率最高。尽管如此，阿朗佐仍与普林斯顿的其他居民保持着定期接触。其中包括阿兰·图灵、约翰·冯·诺依曼和库尔特·哥德尔。</font></font></font></p>
<p>The four men were interested in formal systems. They didn't pay much heed to the physical world, they were
interested in dealing with abstract mathematical puzzles instead. Their puzzles had something in common: the
men were working on answering questions about <em>computation.</em> If we had machines that had infinite computational
power, what problems would we be able to solve? Could we solve them automatically? Could some problems remain
unsolved and why? Would various machines with different designs be equal in power?<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>这四个人对形式系统感兴趣。他们不太关注物理世界，而是对处理抽象的数学难题感兴趣。他们的谜题有一些共同点：这些人都致力于回答有关计算的问题。如果我们拥有具有无限计算能力的机器，我们能够解决什么问题？我们能自动解决它们吗？是否有些问题仍未解决？为什么？不同设计的各种机器的功率会相同吗？</font></font></font></p>
<p>In cooperation with other men Alonzo Church developed a formal system called <em>lambda calculus.</em> The
system was essentially a programming language for one of these imaginary machines. It was based on functions
that took other functions as parameters and returned functions as results. The function was identified by a
Greek letter lambda, hence the system's name<sup><a href=#lambda>4</a></sup>. Using this formalism
Alonzo was able to reason about many of the above questions and provide conclusive answers.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>阿隆佐·丘奇 (Alonzo Church) 与其他人合作开发了一种称为 lambda 演算的形式系统。该系统本质上是这些虚拟机器的一种编程语言。它基于将其他函数作为参数并返回函数作为结果的函数。该函数由希腊字母 lambda 标识，系统由此得名 <sup><a href=#lambda>4</a></sup> <i>（译注：据说这个希腊字母 Λ (小写即 λ ) 的来源其实是对原本的 ^ 符号的誊写失误而造成的 …… 它本身并无什么深刻或者神秘含义在里头）</i>。使用这种形式论<i>（译注：本文所有 “formalism” 应该都是指 “形式方面的方法论、形式方面的观念形态” 这样的意思。我这里都译作“形式论”，你也可以姑且就简单直白地把它看成是“形式方式”）</i>，阿朗佐能够推理出上述许多问题（的形式对应）并提供结论性的答案。</font></font></font></p>
<p>Independently of Alonzo Church, Alan Turing was performing similar work. He developed a different
formalism (now referred to as the Turing machine), and used it to independently come to similar conclusions as
Alonzo. Later it was shown that Turing machines and lambda calculus were equivalent in power.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>独立于阿朗佐·丘奇之外，艾伦·图灵也在进行类似的工作。他开发了一种不同的形式论（现在称为图灵机），并用它独立地得出了与阿朗佐类似的结论。后来证明图灵机和 lambda 演算在功效上是等效的。</font></font></font></p>
<p>This is where the story would stop, I'd wrap up the article, and you'd navigate to another page, if not
for the beginning of World War II. The world was in flames. The U.S. Army and Navy used artillery more often
than ever. In attempts to improve accuracy the Army employed a large group of mathematicians to continuously
calculate differential equations required for solving ballistic firing tables. It was becoming obvious that
the task was too great for being solved manually and various equipment was developed in order to overcome
this problem. The first machine to solve ballistic tables was a Mark I built by IBM - it weighed five tons,
had 750,000 parts and could do three operations per second.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>故事到这里就结束了，我将会结束这篇文章，你也将被导航到另一个页面，如果后来没有第二次世界大战的话。世界陷入火海之中。美国陆军和海军比以往任何时候都更频繁地使用火炮。为了提高准确性，陆军雇用了一大批数学家来不断计算求解弹道发射表所需的微分方程。很明显，这项任务对于手动解决来说太大了，为了克服这个问题，人们开发了各种设备。第一台求解弹道表的机器是 IBM 制造的 Mark I ：它重 5 吨，有 750,000 个零件，每秒可以执行 3 次操作。</font></font></font></p>
<p>The race, of course, wasn't over. In 1949 an Electronic Discrete Variable Automatic Computer (<em>EDVAC</em>)
was unveiled and had tremendous success. It was a first example of von Neumann's architecture and was effectively
a real world implementation of a Turing machine. For the time being Alonzo Church was out of luck.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>当然，比赛还没有结束。 1949 年，电子离散变量自动计算机 (EDVAC) 面世并取得了巨大成功。这是冯·诺依曼架构的第一个示例，实际上是图灵机的现实世界实现。目前阿朗佐·丘奇的运气不太好。</font></font></font></p>
<p>In late 1950s an MIT professor John McCarthy (also a Princeton graduate) developed interest in Alonzo
Church's work. In 1958 he unveiled a List Processing language (Lisp). Lisp was an implementation of Alonzo's
lambda calculus that worked on von Neumann computers! Many computer scientists recognized the expressive
power of Lisp. In 1973 a group of programmers at MIT's Artificial Intelligence Lab developed hardware they
called a Lisp machine - effectively a native hardware implementation of Alonzo's lambda calculus!<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>20 世纪 50 年代末，麻省理工学院教授约翰·麦卡锡（也是普林斯顿大学毕业生）对阿朗佐·丘奇的工作产生了兴趣。 1958 年，他推出了列表处理语言 (Lisp)。 Lisp 是 Alonzo 的 lambda 演算的实现，可在冯诺依曼计算机上运行！许多计算机科学家认识到 Lisp 的表达能力。 1973 年，麻省理工学院人工智能实验室的一群程序员开发了他们称之为 “Lisp 机” 的硬件 —— 实际上是 Alonzo 的 lambda 演算的原生硬件实现！</font></font></font></p>
<h2><a id=part_4>Functional Programming<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> 函数式编程</font></font></font></a></h2>
<p class=first>Functional programming is a practical implementation of Alonzo Church's ideas. Not all lambda
calculus ideas transform to practice because lambda calculus was not designed to work under physical limitations.
Therefore, like object oriented programming, functional programming is a set of ideas, not a set of strict guidelines.
There are many functional programming languages, and most of them do many things very differently. In this article I will explain
the most widely used ideas from functional languages using examples written in Java (yes, you could write
functional programs in Java if you felt particularly masochistic). In the next couple of sections we'll take
Java as is, and will make modifications to it to transform it into a useable functional language. Let's
begin our quest.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>函数式编程是 Alonzo Church 思想的实际实现。并非所有 lambda 演算思想都能转化为实践，因为 lambda 演算并非设计用于在物理限制下工作。因此，与面向对象编程一样，函数式编程是一套思想，而不是一套严格的准则。函数式编程语言有很多种，它们中的大多数在做的事情也都非常不同。在本文中，我将使用 Java 编写的示例来解释函数式语言中最广泛使用的思想（是的，您可以在 Java 用函数式思想编写程序，如果您想体验一种特别受虐的话）。在接下来的几节中，我们将按原样使用 Java，并对它进行修改，将其转换为可用的函数式语言。让我们开始我们的探索吧。</font></font></font></p>
<p>Lambda calculus was designed to investigate problems related to <em>calculation.</em> Functional programming,
therefore, primarily deals with calculation, and, surprisingly, uses functions to do so. A function is a very
basic unit in functional programming. Functions are used for almost everything, even the simplest of calculations.
Even variables are replaced with functions. In functional programming variables are simply aliases for expressions
(so we don't have to type everything on one line). They cannot be modified. All variables can only be assigned to
once. In Java terms this means that every single variable is declared as <em>final</em> (or <em>const</em> if we're
dealing with C++). There are no non-final variables in FP.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>Lambda 演算旨在研究与计算相关的问题。因此，函数式编程主要处理计算，并且令人惊讶的是，它使用函数来执行此操作。函数是函数式编程中非常基本的单元。函数几乎用于所有事情，甚至是最简单的计算。甚至变量也被函数取代。在函数式编程中，变量只是表达式的别名（从而令我们可以不必在一行中输入所有内容）。它们不能被修改。所有变量只能分配一次。用 Java 术语来说，这意味着每个变量都被声明为 Final（如果我们处理的是 C++，则声明为 const）。 FP 中没有非“最终”的变量。</font></font></font></p>
<pre>final int i = 5;
final int j = i + 3;
</pre>
<p>Since every variable in FP is final two fairly interesting statements can be made. It does not make sense to always
write the keyword <em>final</em> and it does not make sense to call variables, well... variables. We will now make
two modifications to Java: every variable declared in our functional Java will be final by default, and we will
refer to variables as <em>symbols.</em><font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>由于 FP 中的每个变量都是最终变量，因此可以给出两句相当有趣的东西：总是写关键字 final 是没有意义的，并且把它叫作变量也是没有意义的 …… “变量”，嗯 …… 。现在，我们将对 Java 进行两处修改：在函数式（方式下的） Java 中声明的每个变量默认都是最终变量，并且我们将变量称为 “符号” (<em>symbols</em>) 。</font></font></font></p>
<p>By now you are probably wondering how you could possibly write anything reasonably complicated in our newly created
language. If every symbol is non-mutable we cannot change the state of anything! This isn't strictly true. When Alonzo
was working on lambda calculus he wasn't interested in maintaining state over periods of time in order to modify it
later. He was interested in performing operations on data (also commonly referred to as "calculating stuff"). However,
it was proved that lambda calculus is equivalent to a Turing machine. It can do all the same things an imperative
programming language can. How, then, can we achieve the same results?<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>现在您可能想知道如何用我们新创建的语言编写相当复杂的东西。如果每个符号都是不可变的，我们就无法改变任何东西的状态！这并不完全正确。当 Alonzo 致力于 lambda 演算时，他对在一段时间内维护状态以便稍后修改它不感兴趣。他对对数据执行操作（通常也称为“计算内容”）感兴趣。然而，事实证明， lambda 演算相当于图灵机。它可以做命令式编程语言可以做的所有事情。那么，我们怎样才能达到同样的结果呢？</font></font></font></p>
<p>It turns out that functional programs can keep state, except they don't use variables to do it. They use functions
instead. The state is kept in function parameters, on the stack. If you want to keep state for a while and every now
and then modify it, you write a recursive function. As an example, let's write a function that reverses a Java string.
Remember, every variable we declare is final by default<sup><a href=#strings-final>5</a></sup>.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>事实证明，函数式程序可以保持状态，只是它们不使用变量来做到这一点。他们使用函数来代替。状态保存在堆栈上的函数参数中。如果您想保留状态一段时间并时不时地修改它，您可以编写一个递归函数。作为示例，让我们编写一个反转 Java 字符串的函数。请记住，我们声明的每个变量默认都是最终的 <sup><a href=#strings-final>5</a></sup> 。</font></font></font></p>
<pre>String reverse(String arg) {
    if(arg.length == 0) {
        return arg;
    }
    else {
        return reverse(arg.substring(1, arg.length)) + arg.substring(0, 1);
    }
}
</pre>
<p>This function is slow because it repeatedly calls itself<sup><a href=#tail-calls>6</a></sup>. It's a memory hog because it repeatedly allocates objects.
But it's functional in style. You may be interested why someone would want to program in this manner. Well, I was just about
to tell you.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>该函数很慢，因为它重复调用自身 <sup><a href=#tail-calls>6</a></sup> 。它非常消耗内存，因为它会重复分配对象。<b>但它的风格很实用</b>。您可能会感兴趣为什么有人想要以这种方式进行编程。嗯，我正想告诉你。</font></font></font></p>
<h2><a id=part_5>Benefits of FP<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> FP 的好处</font></font></font></a></h2>
<p class=first>You're probably thinking that there's no way I can rationalize the monstrosity of a function above.
When I was learning functional programming I was thinking that too. I was wrong. There are very good arguments for
using this style. Some of them are subjective. For example, people claim that functional programs are easier to
understand. I will leave out these arguments because every kid on the block knows that ease of understanding is in
the eye of the beholder. Fortunately for me, there are plenty of objective arguments.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>您可能会认为我会无法将上述函数的臃肿与丑陋的性质合理化。当我学习函数式编程时我也是这么想的。我错了。使用这种风格有很好的论据。其中一些是主观的。例如，人们声称函数式程序更容易理解。我将省略这些论点，因为街区里的每个孩子都知道理解的难易程度取决于情人的眼睛。对我来说幸运的是，有很多客观的论据。</font></font></font></p>
<h3>Unit Testing<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>单元测试</font></font></font></h3>
<p class=first>Since every symbol in FP is final, no function can ever cause side effects. You can never modify
things in place, nor can one function modify a value outside of its scope for another function to use (like a class member
or a global variable). That means that the only effect of evaluating a function is its return value and the only thing
that affects the return value of a function is its arguments.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>由于 FP 中的每个符号都是最终的，因此任何函数都不会产生副作用。您永远不能就地修改内容，一个函数也不能修改其范围之外的值以供另一个函数使用（例如类成员或全局变量）。这意味着计算函数的唯一效果是它的返回值，而影响函数返回值的唯一因素是它的参数。</font></font></font></p>
<p>This is a unit tester's wet dream. You can test every function in your program only worrying about its arguments.
You don't have to worry about calling functions in the right order, or setting up external state properly. All you need
to do is pass arguments that represent edge cases. If every function in your program passes unit tests you can be
a lot more confident about quality of your software than if you were using an imperative language. In Java or C++
checking a return value of a function is not sufficient - it may modify external state that we would need to verify. Not
so in a functional language.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>这是单元测试人员的梦遗。您可以测试程序中的每个函数，只需要担心它的参数。您不必担心以正确的顺序调用函数，或正确设置外部状态。您所需要做的就是传递代表边缘情况的参数（ arguments that represent edge cases ）。如果程序中的每个函数都通过了单元测试，那么与使用命令式语言相比，您可以对软件的质量更有信心。在 Java 或 C++ 中，检查函数的返回值是不够的 —— 它可能会修改我们需要验证的外部状态。在函数式语言中并非如此。</font></font></font></p>
<h3>Debugging<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>调试</font></font></font></h3>
<p class=first>If a functional program doesn't behave the way you expect it to, debugging it is a breeze. You will
always be able to reproduce your problem because a bug in a functional program doesn't depend on unrelated code paths that
were executed before it. In an imperative program a bug resurfaces only some of the time. Because functions depend on external
state produced by side effects from other functions you may have to go through a series of steps in no way related to the
bug. In a functional program this isn't the case - if a return value of a function is wrong, it is <em>always</em> wrong,
regardless of what code you execute before running the function.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>如果函数式程序的行为不符合您的预期，调试它也将是轻而易举的。您始终能够重现您的问题，因为函数式程序中的错误并不依赖于在其之前执行的不相关的代码路径。在命令式程序中，错误仅在某些时候重新出现。由于函数依赖于其他函数的副作用所产生的外部状态，因此您可能必须执行一系列与错误无关的步骤。在函数式程序中，情况并非如此 —— 如果函数的返回值错误，那么无论您在运行该函数之前执行什么代码，它总是错误的。</font></font></font></p>
<p>Once you reproduce the problem, getting to the bottom of it is trivial. It is almost pleasant. You break the execution
of your program and examine the stack. Every argument in every function call in the stack is available for your
inspection, just like in an imperative program. Except in an imperative program that's not enough because functions
depend on member variables, global variables, and the state of other classes (which in turn depend on these very same things). A
function in a functional program depends <em>only</em> on its arguments, and that information is right before your eyes! Furthermore,
in an imperative program examining a return value of a function will not give you a good idea of whether the function
behaves properly. You need to hunt down dozens of objects outside its scope to verify that it performed correct actions. In
a functional program all you have to do is look at the return value!<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>一旦（能）重现问题，找出问题的根源就很简单了。这几乎是令人愉快的。您中断程序的执行并检查堆栈。堆栈中每个函数调用中的每个参数都可供您检查，就像在命令式程序中一样。当然，在命令式程序中，只是这还是不够的，因为函数依赖于成员变量、全局变量和其他类的状态（而其他类又依赖于这些相同的东西）；但函数式程序中的函数仅取决于其参数，并且该信息就在您眼前！此外，在命令式程序中，检查函数的返回值不会让您很好地了解该函数是否运行正常。您需要搜寻其范围之外的数十个对象，以验证它是否执行了正确的操作。在函数式程序中，您所要做的就只有查看返回值！仅此而已！</font></font></font></p>
<p>Walking through the stack you look at arguments passed to functions and their return values. The minute a return value
doesn't make sense you step into the offending function and walk through it. You repeat this recursively until the process
leads you to the source of the bug!<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>浏览堆栈时，您会看到传递给函数的参数及其返回值。一旦发现返回值有什么毛病，您就可以进入对应的有问题的函数并遍历它。<i>（译注：然后继续一个一个一个地找到可能存在的有问题的返回，然后再进入对应的函数调用遍历。）</i>您递归地重复此操作，直到该过程引导您找到错误的根源！</font></font></font></p>
<h3>Concurrency<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>并发性</font></font></font></h3>
<p class=first>A functional program is ready for concurrency without any further modifications. You never have to worry about
deadlocks and race conditions because you don't need to use locks! No piece of data in a functional program is modified twice
by the same thread, let alone by two different threads. That means you can easily add threads without ever giving
conventional problems that plague concurrency applications a second thought!<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>函数式程序无需任何进一步修改即可实现并发。您永远不必担心死锁和竞争条件，因为您不需要使用锁！函数式程序中的任何数据都不会被同一线程修改两次，更不用说被两个不同的线程修改了。这意味着您可以轻松添加线程，而无需再考虑困扰并发应用程序的传统问题！</font></font></font></p>
<p>If this is the case, why doesn't anybody use functional programs for highly concurrent applications? Well, it turns out
that they do. Ericsson designed a functional language called <a href=http://www.erlang.org/>Erlang</a> for use in its highly tolerant
and scalable telecommunication switches. Many others recognized the benefits provided by Erlang and started <a href=http://www.erlang.org/faq/faq.html#AEN50>using
it</a>. We're talking about telecommunication and traffic control systems that are far more scalable and reliable than
typical systems designed on Wall Street. Actually, Erlang systems are not scalable and reliable. Java systems are. Erlang
systems are simply rock solid.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>如果是这样的话，为什么没有人将函数式程序用于高并发应用程序呢？好吧，事实证明确实有人这样做了。爱立信设计了一种名为 Erlang 的函数式语言，用于其高度宽容和可扩展的电信交换机。许多其他人认识到 Erlang 提供的好处并开始使用它。我们谈论的是电信和交通控制系统，它们比华尔街设计的典型系统更具可扩展性和可靠性。实际上，Erlang 系统并没必要被强调什么具有可扩展性和可靠性， Java 系统才有。 Erlang 系统仅仅只是无比单纯地坚如磐石而已。</font></font></font></p>
<p>The concurrency story doesn't stop here. If your application is inherently single threaded the compiler can still optimize
functional programs to run on multiple CPUs. Take a look at the following code fragment:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>并发故事并没有就此结束。如果您的应用程序本质上是单线程的，编译器仍然可以优化函数式程序以在多个 CPU 上运行。看一下下面的代码片段：</font></font></font></p>
<pre>String s1 = somewhatLongOperation1();
String s2 = somewhatLongOperation2();
String s3 = concatenate(s1, s2);
</pre>
<p>In a functional language the compiler could analyze the code, classify the functions that create strings <em>s1</em> and
<em>s2</em> as potentially time consuming operations, and run them concurrently. This is
impossible to do in an imperative language because each function may modify state outside of its scope and the function
following it may depend on it. In functional languages automatic analysis of functions and finding good candidates for
concurrent execution is as trivial as automatic inlining! In this sense functional style programs are "future proof" (as
much as I hate buzzwords, I'll indulge this time). Hardware manufacturers can no longer make CPUs run any faster. Instead
they increase the number of cores and attribute quadruple speed increases to concurrency. Of course they conveniently
forget to mention that we get our money's worth only on software that deals with parallelizable problems. This is a very small
fraction of imperative software but 100% of functional software because functional programs are all parallelizable out
of the box.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>在函数式语言中，编译器可以分析代码，将创建字符串 s1 和 s2 的函数分类为潜在耗时的操作，并同时运行它们。这在命令式语言中是不可能做到的，<b>因为每个函数都可能修改其范围之外的状态，并且它后面的函数可能依赖于它。</b>在函数式语言中，函数的自动分析和找到并发执行的良好候选者<b> <i>就像自动内联一样微不足道</i> ！</b>从这个意义上说，函数式风格的程序是“面向未来的”（尽管我讨厌流行语，但这次我会沉迷其中）。硬件制造商无法再让 CPU 运行得更快。相反，它们增加了核心数量，并将并发速度提高了四倍。当然，他们很容易忘记提及，我们只有在处理可并行问题的软件上才能物有所值。这在命令式软件中只有很小的可能被发挥，但在函数式软件却是 100% 会发挥的，因为函数式程序都是开箱即用的可并行化。</font></font></font></p>
<h3>Hot Code Deployment<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>热代码部署</font></font></font></h3>
<p class=first>In the old days of Windows in order to install updates it was necessary to restart the computer. Many times.
After installing a newer version of a media players. With Windows XP the situation has improved significantly, yet it still
isn't ideal (I ran Windows Update at work today and now an annoying system tray icon won't go away until I restart). Unix
systems have had a better model for a while. In order to install an update you only need to stop relevant components, not the
whole OS. While it is a better situation, for a large class of server applications it still isn't acceptable. Telecommunication
systems need to be up 100% of the time because if dialing emergency is not available due to upgrades, lives may be lost. There is
no reason Wall Street firms need to bring down their systems to install software updates over the weekend.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>在过去的 Windows 时代，为了安装更新，必须重新启动计算机，而且是可能很多次，而这只是在安装了新版本的媒体播放器之后。等到用上 Windows XP ，情况有了显着改善，但仍然不理想（我今天在工作中运行了 Windows Update ，现在恼人的系统托盘图标在我重新启动之前不会消失）。一段时间以来， Unix 系统已经有了更好的模型。为了安装更新，您只需停止相关组件，而不是整个操作系统。虽然这是一个更好的情况，但对于一大类服务器应用程序来说，这仍然是不可接受的。电信系统需要在 100% 的时间里保持正常运行，因为如果由于升级而无法拨打紧急电话，则可能会造成人员伤亡。华尔街公司没有理由或者需要去在周末把系统给关掉来安装软件更新。</font></font></font></p>
<p>An ideal situation is updating relevant parts of the code without stopping any part of the system at all. In an imperative
world this isn't possible. Consider unloading a Java class at runtime and reloading a new definition. If we were to do
that every instance of a class would become unusable because the state it holds would be lost. We would need to resort to
writing tricky version control code. We'd need to serialize all running instances of the class, destroy them, create
instances of the new class, try to load serialized data into them hoping the loading code properly migrates the data to work
with the new instance. On top of that, every time we change something we'd have to write our migration code manually.
And our migration code would have to take special care not to break relationships between objects.
Nice in theory, but would never work well in practice.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>理想的情况是更新代码的相关部分而不停止系统的任何部分。在一个命令式的世界里这是不可能的。试想一下在运行时卸载 Java 类并重新加载新定义。如果我们这样做，类的每个实例都将变得不可用，因为它所保存的状态将会丢失。我们需要编写棘手的版本控制代码。我们需要序列化该类的所有正在运行的实例，销毁它们，创建新类的实例，尝试将序列化数据加载到其中，希望加载代码正确迁移数据以能与新实例一起使用。最重要的是，每次我们更改某些内容时，我们都必须<i>（译注：有可能是从头）</i>手动编写迁移代码。我们的迁移代码必须特别小心，不要破坏对象之间的关系。这在理论上或许仍然可行，但在实践中这样搞永远行不通。</font></font></font></p>
<p>In a functional program all state is stored on the stack in the arguments passed to functions. This makes hot deployment
significantly easier! In fact, all we'd really have to do is run a diff between the code in production and the new version,
and deploy the new code. The rest could be done by language tools automatically! If you think this is science fiction, think
again. Erlang engineers have been <a href=http://www.erlang.org/doc/reference_manual/code_loading.html#12.3>upgrading</a>
live systems without stopping them for years.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>在函数式程序中，所有状态都存储在传递给函数的参数中的堆栈中。这使得热部署变得更加容易！事实上，我们真正要做的就是对生产中的代码和新版本二者运行一下 diff ，然后部署新代码。剩下的就可以由语言工具自动完成！如果您认为这是科幻小说，请再想一想。 Erlang 工程师多年来就是在一直在不间断地 <a herf=http://www.erlang.org/doc/reference_manual/code_loading.html#12.3>升级</a> 一个不停运行中的系统。</font></font></font></p>
<h3>Machine Assisted Proofs and Optimizations<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>机器辅助证明和优化</font></font></font></h3>
<p class=first>An interesting property of functional languages is that they can be reasoned about mathematically. Since
a functional language is simply an implementation of a formal system, all mathematical operations that could be done on
paper still apply to the programs written in that language. The compiler could, for example, convert pieces of code into
equivalent but more efficient pieces with a mathematical proof that two pieces of code are equivalent<sup><a href=#proof>7</a></sup>.
Relational databases have been performing these optimizations for years. There is no reason the same techniques can't apply
to regular software.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>函数式语言的一个有趣的特性是它们可以用数学方式进行推理。由于函数式语言只是形式系统的实现，因此可以在纸上完成的所有数学运算仍然适用于用该语言编写的程序。例如，编译器可以将代码段转换为等效但更高效的代码段，并通过数学证明证明两段代码是等效的 <sup><a href=#proof>7</a></sup> 。关系数据库多年来一直在执行这些优化。相同的技术没有理由不能应用于常规软件。</font></font></font></p>
<p>Additionally, you can use these techniques to prove that parts of your program are correct. It is even possible to create tools
that analyze code and generate edge cases for unit tests automatically! This functionality is invaluable for rock solid systems.
If you are designing pace makers and air traffic control systems such tools are almost always a requirement. If you are writing
an application outside of truly mission critical industries, these tools can give you a tremendous edge over your competitors.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>此外，您可以使用这些技术来证明程序的某些部分是正确的。甚至可以创建自动分析代码并生成单元测试边缘情况的工具！这项能力（此函数性能力）对于坚如磐石的系统来说是无价的。如果您正在设计起搏器和空中交通管制系统，则几乎总是需要此类工具。如果您正在真正的任务关键型行业之外编写应用程序，这些工具可以为您提供超越竞争对手的巨大优势。</font></font></font></p>
<h2><a id=part_6>Higher Order Functions<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> 高阶函数</font></font></font></a></h2>
<p class=first>I remember learning about the benefits I outlined above and thinking "that's all very nice but it's useless
if I have to program in a crippled language where everything is final." This was a misconception. Making all variables final
<em>is</em> crippled in a context of an imperative language like Java but it isn't in a context of functional languages. Functional
languages offer a different kind of abstraction tools that make you forget you've ever <em>liked</em> modifying variables. One
such tool is capability to work with <em>higher order functions.</em><font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>我记得在了解上面概述的好处时，我有想过 “这一切都很好，但如果我必须使用一种一切都是最终决定的残缺语言进行编程，那就毫无用处了。” 这其实是一个误解。在像 Java 这样的命令式语言环境中，将所有变量设为最终变量如同变成残废，但在函数式语言环境中则不然。函数式语言提供了一种不同类型的抽象工具，让您忘记自己曾经喜欢修改变量。其中一种工具是处理高阶函数的能力。</font></font></font></p>
<p>A function in such languages is different from a function in Java or C. It is a superset - it can do all the things a Java
function can do, and more. We create a function in the same manner we do in C:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>此类语言中的函数与 Java 或 C 中的函数不同。它是一个超集 —— 它可以执行 Java 函数可以执行的所有操作，甚至更多。我们以与在 C 中相同的方式创建一个函数：</font></font></font></p>
<pre>int add(int i, int j) {
    return i + j;
}
</pre>
<p>This means something different from equivalent C code. Let's extend our Java compiler to support this notation. When we
type something like this our compiler will convert it to the following Java code (don't forget, everything is final):<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>这意味着与等效的 C 代码不同的东西。让我们扩展 Java 编译器来支持这种表示法。当我们输入这样的内容时，我们的编译器会将其转换为以下 Java 代码（不要忘记，一切都是最终<i>（译注：即不可变）</i>的）：</font></font></font></p>
<pre>class add_function_t {
    int add(int i, int j) {
        return i + j;
    }
}

add_function_t add = new add_function_t();
</pre>
<p>The symbol <em>add</em> isn't really a function. It is a small class with one function as its member. We can now pass
<em>add</em> around in our code as an argument to other functions. We can assign it to another symbol. We can create instances
of <em>add_function_t</em> at runtime and they will be garbage collected when we no longer need them. This makes functions
<em>first class objects</em> no different from integers or strings. Functions that operate on other functions (accept them
as arguments) are called <em>higher order functions.</em> Don't let this term intimidate you, it's no different from Java
classes that operate on each other (we can pass class instances to other classes). We can call them "higher order classes" but nobody
cares to because there is no strong academic community behind Java.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>符号 add 并不是真正的函数。它是一个小类，其成员只有一个函数。现在，我们可以在代码中将 add 作为参数传递给其他函数。我们可以将它分配给另一个符号。我们可以在运行时创建 add_function_t 的实例，当我们不再需要它们时，它们将被垃圾回收。这使得函数成为第一级对象，与整数或字符串没有什么不同。对其他函数进行操作（接受它们作为参数）的函数称为高阶函数。不要让这个术语吓倒您，它与相互操作的 Java 类没有什么不同（我们可以将类实例传递给其他类）。我们当然也可以称它们为“高阶类”，但没有人关心，因为 Java 背后没有强大的学术社区。</font></font></font></p>
<p>How, and when, do you use higher order functions? Well, I'm glad you asked. You write your program as a big monolithic
blob of code without worrying about class hierarchies. When you see that a particular piece of code is repeated, you break it
out into a function (fortunately they still teach this in schools). If you see that a piece of logic within your function needs
to behave differently in different situations, you break it out into a higher order function. Confused? Here's a real life
example from my work.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>您如何以及何时使用高阶函数？嗯，我对你的提问感到很高兴。您可以将程序编写为一个大的整体代码块，而不必担心类层次结构。当您看到重复的特定代码段时，您可以将其分解为一个函数（幸运的是在学校也仍然教授这一点）。如果您发现函数中的一段逻辑需要在不同情况下表现不同，您可以将其分解为更高阶的函数。困惑吗？下面是我工作中的一个活生生的例子。</font></font></font></p>
<p>Suppose we have a piece of Java code that receives a message, transforms it in various ways, and forwards it to another
server.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>假设我们有一段 Java 代码，它接收消息，以各种方式对其进行转换，然后将其转发到另一台服务器。</font></font></font></p>
<pre>class MessageHandler {
    void handleMessage(Message msg) {
        // ...
        msg.setClientCode("ABCD_123");
        // ...
        
        sendMessage(msg);
    }
    
    // ...
}
</pre>
<p>Now imagine that our system has changed and we now route messages to two servers instead of one. Everything is handled
in exactly the same way except the client code - the second server wants it in a different format. How do we handle this
situation? We could check where the message is headed and format the client code differently, like this:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>现在想象一下我们的系统已经改变，我们现在将消息路由到两台服务器而不是一台。除了客户端代码之外，所有内容都以完全相同的方式处理 —— 第二个服务器希望它采用不同的格式。我们如何处理这种情况？我们可以检查消息的标题并以不同的方式格式化客户端代码，如下所示：</font></font></font></p>
<pre>class MessageHandler {
    void handleMessage(Message msg) {
        // ...
        if(msg.getDestination().equals("server1") {
            msg.setClientCode("ABCD_123");
        } else {
            msg.setClientCode("123_ABC");
        }
        // ...
        
        sendMessage(msg);
    }
    
    // ...
}
</pre>
<p>This approach, however, isn't scalable. If more servers are added our function will grow linearly and we'll have a nightmare
updating it. An object oriented approach is to make <em>MessageHandler</em> a base class and specialize the client code
operation in derived classes:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>然而，这种方法不可扩展。如果添加更多服务器，我们函数的定义体将线性地增大，这玩意儿的更新工作也将会是一场噩梦。面向对象的解决办法是将 MessageHandler 作为基类，并在派生类的代码中再去做针对特定客户端的操作：</font></font></font></p>
<pre>abstract class MessageHandler {
    void handleMessage(Message msg) {
        // ...
        msg.setClientCode(getClientCode());
        // ...
        
        sendMessage(msg);
    }
    
    abstract String getClientCode();
    
    // ...
}

class MessageHandlerOne extends MessageHandler {
    String getClientCode() {
        return "ABCD_123";
    }
}

class MessageHandlerTwo extends MessageHandler {
    String getClientCode() {
        return "123_ABCD";
    }
}
</pre>
<p>We can now instantiate an appropriate class for each server. Adding servers becomes much more maintainable. That's a lot of
code for such a simple modification though. We have to create two new types just to support different client codes! Now let's do
the same thing in our language that supports higher order functions:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>我们现在可以为每个服务器实例化一个适当的类。添加服务器变得更易于维护。对于这样一个简单的修改来说，代码量很大。我们必须创建足足两种新类型，却仅仅只是为了写针对不同的客户端的代码！现在让我们用支持高阶函数的语言做同样的事情<i>（译注：上面作者已经证明过了可以用一点麻烦的手段让 Java 的函数也可以作为值到处传递了，所以下面代码中的函数你们就假装它们是也能支持像值一样去传递的就行。以及之后还会有更多的只是借用 Java 语法来表达意思的代码，它们（至少目前）并不能<b>直接</b>作为正常的 Java 代码使用（如果能就好了作者也甭写这么一篇文章了）。）</i>：</font></font></font></p>
<pre>class MessageHandler {
    void handleMessage(Message msg, Function getClientCode) {
        // ...
        Message msg1 = msg.setClientCode(getClientCode());
        // ...
        
        sendMessage(msg1);
    }
    
    // ...
}

String getClientCodeOne() {
    return "ABCD_123";
}

String getClientCodeTwo() {
    return "123_ABCD";
}

MessageHandler handler = new MessageHandler();
handler.handleMessage(someMsg, getClientCodeOne);
</pre>
<p>We've created no new types and no class hierarchy. We simply pass appropriate functions as a parameter. We've achieved the same
thing as the object oriented counterpart with a number of advantages. We don't restrict ourselves to class hierarchies: we can pass
new functions at runtime and change them at any time with a much higher degree of granularity with less code. Effectively the compiler
has written object oriented "glue" code for us! In addition we get all the other benefits of FP. Of course the abstractions provided
by functional languages don't stop here. Higher order functions are just the beginning.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>我们没有创建新类型，也没有类层次结构。我们只需将适当的函数作为参数传递即可。我们已经实现了与面向对象的对应物相同的目标，并具有许多优点。我们不将自己限制在类层次结构中：我们可以在运行时传递新函数，并以更少的代码以更高的粒度随时更改它们。实际上，编译器已经为我们编写了面向对象的“粘合”代码！此外，我们还获得了 FP 的所有其他好处。当然，函数式语言提供的抽象并不止于此。高阶函数仅仅是开始。<i>（译注：多说一句。在意识形态学上， FP 相对于 OO 带来的这项革新也将类似于（关注一个事物如何是（“是”在此指一种行动）它的）辩证法相对于（那种低端的具有整全幻想的）形而上学而言所带来的革新一样。）</i></font></font></font></p>
<h2><a id=part_7>Currying<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> 柯里化</font></font></font></a></h2>
<p class=first>Most people I've met have read the <a href=http://www.amazon.com/gp/product/0201633612/103-9055240-2348603>
Design Patterns</a> book by the Gang of Four. Any self respecting programmer will tell you that the book is language agnostic
and the patterns apply to software engineering in general, regardless of which language you use. This is a noble claim. Unfortunately
it is far removed from the truth.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>我遇到的大多数人都读过 GoF 的《设计模式》一书。任何有自尊心的程序员都会告诉你，这本书与语言无关，并且无论你使用哪种语言，这些模式都适用于一般的软件工程。这是一个崇高的主张。不幸的是，这与事实相去甚远。</font></font></font></p>
<p>Functional languages are extremely expressive. In a functional language one does not need design patterns because the language
is likely so high level, you end up programming in concepts that eliminate design patterns all together. Once such pattern is an 
Adapter pattern (how is it different from Facade again? Sounds like somebody needed to fill more pages to satisfy their contract).
It is eliminated once a language supports a technique called <em>currying</em>.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>函数式语言极具表现力。在函数式语言中，不需要设计模式，因为该语言可能非常高级，你最终会用完全淘汰掉设计模式之后的概念来编程。其中一种模式就是适配器（Adapter）模式（它与 Facade 又有什么不同？听起来好像有人需要填充更多的页面来满足他们的约定）：它会被淘汰，一旦一种语言支持称为柯里化（currying）的技术了的话。</font></font></font></p>
<p>Adapter pattern is best known when applied to the "default" abstraction unit in Java - a class. In functional languages the
pattern is applied to functions. The pattern takes an interface and transforms it to another interface someone else expects.
Here's an example of an adapter pattern:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>适配器模式最为人熟知的应用是 Java 中的“默认”抽象单元 —— 类。在函数式语言中，该模式应用于函数。该模式采用一个接口并将其转换为其他人期望的另一个接口。以下是适配器模式的示例：</font></font></font></p>
<pre>int pow(int i, int j);
int square(int i)
{
    return pow(i, 2);
}
</pre>
<p>The code above adapts an interface of a function that raises an integer to an integer power to an interface of a function
that squares an integer. In academic circles this trivial technique is called currying (after a logician Haskell Curry who
performed mathematical acrobatics necessary to formalize it). Because in FP functions (as opposed to classes) are passed around
as arguments, currying is used very often to adapt functions to an interface that someone else expects. Since the interface to
functions is its arguments, currying is used to reduce the number of arguments (like in the example above).<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>上面的代码将一个将整数求整数幂的函数接口改编为一个对整数求平方的函数接口。在学术界，这种微不足道的技术被称为柯里化（以逻辑学家 Haskell Curry 的名字命名，他执行了将其形式化所需的数学杂技）<i>（译注：柯里化和函数部分应用是相似的，但其实不太一样。不过本文并未对此作出区别）</i>。因为在 FP 中函数（而不是类）作为参数传递，所以经常使用柯里化来使函数适应其他人期望的接口。由于函数的接口是其参数，因此柯里化用于减少参数的数量（如上面的示例）。</font></font></font></p>
<p>Functional languages come with this technique built in. You don't need to manually create a function that wraps the original,
functional languages will do that for you. As usual, let's extend our language to support this technique.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>函数式语言内置了这种技术。您无需手动创建包装原始函数的函数，函数式语言将为您完成此操作。像往常一样，让我们​​扩展我们的语言来支持这项技术。</font></font></font></p>
<pre>square = int pow(int i, 2);
</pre>
 <p>This will automatically create a function <em>square</em> for us with one argument. It will call <em>pow</em> function with
 the second argument set to <em>2</em>. This will get compiled to the following Java code:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>这会自动为我们创建一个只有一个参数的函数 square。它将调用第二个参数设置为 2 的 pow 函数：</font></font></font></p>
<pre>class square_function_t {
    int square(int i) {
        return pow(i, 2);
    }
}
square_function_t square = new square_function_t();
</pre>
<p>As you can see, we've simply created a wrapper for the original function. In FP currying is just that - a shortcut to quickly
and easily create wrappers. You concentrate on your task, and the compiler writes the appropriate code for you! When do you use
currying? This should be easy. Any time you'd like to use an adapter pattern (a wrapper).<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>正如您所看到的，我们只是为原始函数创建了一个包装器。在 FP 中，柯里化就仅仅只是这样的 —— 一种快速、轻松地创建包装器的捷径。您专注于您的任务，编译器会为您编写适当的代码！在何时使用柯里化？显而易见：任何您想使用适配器模式（包装器）的时候。</font></font></font></p>
<h2><a id=part_8>Lazy Evaluation<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> 惰性评估</font></font></font></a></h2>
<p class=first>Lazy (or delayed) evaluation is an interesting technique that becomes possible once we adopt a functional
philosophy. We've already seen the following piece of code when we were talking about concurrency:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>惰性（或延迟）评估完全可以是一种有趣的技术，一旦我们采用函数哲学了的话。当我们讨论并发时，我们已经看到过下面这段代码：</font></font></font></p>
<pre>String s1 = somewhatLongOperation1();
String s2 = somewhatLongOperation2();
String s3 = concatenate(s1, s2);
</pre>
<p>In an imperative language the order of evaluation would be clear. Because each function may affect or depend on an external state
it would be necessary to execute them in order: first <em>somewhatLongOperation1</em>, then <em>somewhatLongOperation2</em>, followed
by <em>concatenate</em>. Not so in functional languages.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>在命令式语言中，求值（评估）的顺序是明确的。由于每个函数都可能影响或依赖于外部状态，因此有必要按顺序执行它们：首先是 somethingLongOperation1 ，然后是 somethingLongOperation2 ，最后是连接。在函数式语言中并非如此。</font></font></font></p>
<p>As we saw earlier <em>somewhatLongOperation1</em> and <em>somewhatLongOperation2</em> can be executed concurrently because we're
guaranteed no function affects or depends on global state. But what if we don't want to run the two concurrently, do we need to run
them in order? The answer is no. We only need to run these operations when another function depends on <em>s1</em> and <em>s2</em>.
We don't even have to run them before <em>concatenate</em> is called - we can delay their evaluation until they're required within
<em>concatenate</em>. If we replace <em>concatenate</em> with a function that has a conditional and uses only one of its two parameters
we may never evaluate one of the parameters at all! <a href=http://www.haskell.org/><em>Haskell</em></a> is an example of a delayed
evaluation language. In <em>Haskell</em> you are not guaranteed that anything will be executed in order (or at all) because <em>Haskell</em>
only executes code when it's required.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>正如我们之前看到的 somethingLongOperation1 和 somethingLongOperation2 可以并发执行，因为我们保证没有函数影响或依赖于全局状态。但是，如果我们不是想同时运行两者，是否就只有按顺序运行它们了呢？答案是不：（我们还可以）仅当另一个函数依赖于 s1 和 s2 时才让有必要运行的操作运行。我们甚至不必在调用 concatenate 之前运行它们 —— 我们可以延迟它们的评估，直到 concatenate 中需要它们为止。如果我们将 concatenate 替换为具有条件并仅使用其两个参数之一的函数，我们可能永远不会评估其中一个参数！ Haskell 是延迟评估语言的一个例子。在 Haskell 中，您无法保证任何代码都会按顺序（或根本不按顺序）执行，因为 Haskell 仅在需要时才执行代码。</font></font></font></p>
<p>Lazy evaluation has numerous advantages as well as disadvantages. We will discuss the advantages here and will explain how to counter
the disadvantages in the next section.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>惰性求值有许多优点和缺点。我们将在这里讨论其优点，并在下一节中解释如何克服缺点。</font></font></font></p>
<h3>Optimization<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>优化</font></font></font></h3>
<p class=first>Lazy evaluation provides a tremendous potential for optimizations. A lazy compiler thinks of functional code exactly as mathematicians
think of an algebra expression - it can cancel things out and completely prevent execution, rearrange pieces of code for higher efficiency,
even arrange code in a way that reduces errors, all guaranteeing optimizations won't break the code. This is the biggest benefit of
representing programs strictly using formal primitives - code adheres to mathematical laws and can be reasoned about mathematically.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>惰性求值提供了巨大的优化潜力。惰性编译器对函数代码的思考与数学家对代数表达式的思考完全一样 —— 它可以取消某些内容并完全阻止执行，重新排列代码片段以提高效率，甚至以减少错误的方式排列代码，所有这些都保证优化不会破坏代码。这是严格使用形式原语表示程序的最大好处 —— 代码遵循数学定律并且可以进行数学推理。</font></font></font></p>
<h3>Abstracting Control Structures<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>抽象控制结构</font></font></font></h3>
<p class=first>Lazy evaluation provides a higher order of abstraction that allows implementing things in a way that would otherwise
be impossible. For example consider implementing the following control structure:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>惰性求值提供了一种更高阶的抽象，允许以其他方式实现原本不可能实现的功能。例如，考虑实现以下控制结构：</font></font></font></p>
<pre>unless(stock.isEuropean()) {
    sendToSEC(stock);
}
</pre>
<p>We want <em>sendToSEC</em> executed unless the stock is European. How can we implement <em>unless</em>? Without lazy evaluation
we'd need some form of a macro system, but in a language like Haskell that's unnecessary. We can implement <em>unless</em> as a function!<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>我们希望执行 sendToSEC ，除非股票是欧洲股票。我们要如何实现这个除非（unless）？如果没有惰性求值，我们就需要某种形式的宏系统<i>（译注： SHell 的内置命令 eval 或许就算个例子）</i>，但在像 Haskell 这样的语言中这是不必要的。我们可以将 unless 作为一个函数来实现！<i>（译注：这里其实跟 Elixir 基于“所有关键字都只是表达式”外加语法糖的支持而建立的语法体系非常像了）</i></font></font></font></p>
<pre>void unless(boolean condition, List code) {
    if(!condition)
        code;
}
</pre>
<p>Note that <em>code</em> is never evaluated if the condition is true. We cannot reproduce this behavior in a strict language because
the arguments would be evaluated before <em>unless</em> is entered.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>请注意，这里代码将永远不会被评估，只要条件为真。我们无法在任何严格<i>（译注：即对惰性求值毫不支持）</i>的语言中重现此行为，因为参数全都会在它被输入进 unless 之前就被评估一遍。</font></font></font></p>
<h3>Infinite Data Structures<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>无限数据结构</font></font></font></h3>
<p class=first>Lazy languages allow for definition of infinite data structures, something that's much more complicated in a strict
language. For example, consider a list with Fibonacci numbers. We clearly can't compute and infinite list in a reasonable amount of
time or store it in memory. In strict languages like Java we simply define a Fibonacci function that returns a particular member
from the sequence. In a language like Haskell we can abstract it further and simply define an infinite list of Fibonacci numbers.
Because the language is lazy, only the necessary parts of the list that are actually used by the program are ever evaluated. This
allows for abstracting a lot of problems and looking at them from a higher level (for example, we can use list processing functions
on an infinite list).<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>惰性语言允许定义无限的数据结构，这在严格的语言中要复杂得多。例如，考虑一个包含斐波那契数列的列表。我们显然无法在合理的时间内计算无限列表或将其存储在内存中。在像 Java 这样的严格语言中，我们简单地定义一个斐波那契函数，它返回序列中的特定成员。<i>（译注：其实不太对， Java 的 Stream 就是用于定义无限序列的。以及，不只是 Fibonacci ，借助这种无限序列的数据结构我们还能轻易优雅言简意赅地用 Sieve of Eratosthenes 算法求取素数。）</i>在像 Haskell 这样的语言中，我们可以进一步抽象它并简单地定义斐波那契数的无限列表。由于该语言是惰性的，因此仅评估程序实际使用的列表中必要的部分。这允许抽象很多问题并从更高的层次来看待它们（例如，我们可以将列表处理函数应用在无限列表上）。</font></font></font></p>
<h3>Disadvantages<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>缺点</font></font></font></h3>
<p class=first>Of course there ain't no such thing as a free lunch(tm). Lazy evaluation comes with a number of disadvantages. Mainly that
it is, well, lazy. Many real world problems require strict evaluation. For example consider the following:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>当然，天下没有免费的午餐。惰性求值有很多缺点。主要就是，它很懒。许多现实世界的问题需要严格的评估。例如，考虑以下内容：</font></font></font></p>
<pre>System.out.println("Please enter your name: ");
System.in.readLine();
</pre>
<p>In a lazy language you have no guarantee that the first line will be executed before the second! This means we can't do IO, can't
use native functions in any meaningful way (because they need to be called in order since they depend on side effects), and can't
interact with the outside world! If we were to introduce
primitives that allow ordered code execution we'd lose the benefits of reasoning about our code mathematically (which would take
all of the benefits of functional programming with it). Fortunately not all is lost. Mathematicians got to work and developed a number
of tricks to ensure code gets executed in particular order in a functional setting. We get the best of both worlds! These techniques
include continuations, monads, and uniqueness typing. In this article we'll only deal with continuations. We'll leave monads and
uniqueness typing for another time. Interestingly, continuations are useful for many things other than enforcing a particular order
of evaluation. We'll talk about that as well.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>在惰性语言中，您无法保证第一行将在第二行之前执行！这意味着我们无法进行 IO，无法以任何有意义的方式使用本机函数（因为它们依赖于副作用，因此需要按顺序调用），并且无法与外界交互！如果我们要引入允许有序代码执行的原语，我们就会失去以数学方式推理代码的好处（这玩意儿可是能带来函数式编程的所有好处的）。幸运的是，咱并没失去一切。数学家开始工作并开发了许多技巧，以确保代码在函数设置中按特定顺序执行。我们两全其美！这些技术包括延续、单子和唯一性类型。在本文中，我们将只处理延续。我们将把 monad 和唯一性类型留到下次再讨论。有趣的是，除了强制执行特定的求值顺序之外，延续还有很多用途。我们也会讨论这个。</font></font></font></p>
<h2><a id=part_9>Continuations<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> 续函数</font></font></font></a></h2>
<p class=first>Continuations to programming are what Da Vinci Code is to human history: an amazing revelation of the greatest
cover-up known to man. Well, may be not, but they're certainly revealing of deceit in the same sense as square roots of negative
numbers.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>连续函数对于编程就像《达芬奇密码》对于人类历史的意义：对人类已知的最大掩盖的惊人揭露。嗯，可能不是，但它们确实揭示了欺骗，就像负数的平方根一样。</font></font></font></p>
<p>When we learned about functions we only learned half truths based on a faulty assumption that functions must return their
value to the original caller. In this sense continuations are a generalization of functions. A function must not necessarily return to
its caller and may return to any part of the program. A "continuation" is a parameter we may choose to pass to our function that
specifies where the function should return. The description may be more complicated than it sounds. Take a look at the following
code:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>当我们了解函数时，我们只了解到了一半的事实。基于一个错误的假设，即函数必须将其值返回给原始调用者。从这个意义上说，续函数（延续/续延/续程）是函数的泛化。函数不一定返回到其调用者，并且可以返回到程序的任何部分。一个“延续”是一个我们可以选择传递给函数的参数，用于指定函数应返回的位置。描述可能比听起来更复杂。看一下下面的代码：</font></font></font></p>
<pre>int i = add(5, 10);
int j = square(i);
</pre>
<p>The function <em>add</em> returns <em>15</em> to be assigned to <em>i</em>, the place where <em>add</em> was originally called.
After that the value of <em>i</em> is used to call <em>square</em>. Note that a lazy compiler can't rearrange these lines of
code because the second line depends on successful evaluation of the first. We can rewrite this code block using <em>Continuation
Passing Style</em> or <em>CPS</em>, where the function <em>add</em> doesn't return to the original caller but instead returns its result to
<em>square</em>.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>函数 add 返回 15 分配给 i，也就是最初调用 add 的地方。之后 i 的值被用来调用平方。请注意，惰性编译器无法重新排列这些代码行，因为第二行取决于第一行的成功评估。我们可以使用连续传递样式或 CPS 重写此代码块，其中函数 add 不会返回到原始调用者，而是将其结果返回到 square。<i>（译注：该形式有些像 bind 或者 pipe 这样的东西 ……）</i></font></font></font></p>
<pre>int j = add(5, 10, square);
</pre>
<p>In this case <em>add</em> gets another parameter - a function that <em>add</em> must call with its result upon completion.
In this case <em>square</em> is a continuation of <em>add</em>. In both cases <em>j</em> will equal <em>225</em>.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>在这种情况下，add 获取另一个参数 —— add 必须在完成时调用其结果的函数。在这种情况下，square 是 add 的延续。在这两种情况下 j 都等于 225。</font></font></font></p>
<p>Here lays the first trick to force a lazy language to evaluate two expressions in order. Consider the following (familiar) IO code:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>这是强制惰性语言按顺序计算两个表达式的第一个技巧。考虑以下（熟悉的）IO 代码：</font></font></font></p>
<pre>System.out.println("Please enter your name: ");
System.in.readLine();
</pre>
<p>The two lines don't depend on each other and the compiler is free to rearrange them as it wishes. However, if we rewrite this
code in CPS, there will be a dependency and the compiler will be forced to evaluate the two lines in order!<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>这两行彼此不依赖，编译器可以根据需要自由地重新排列它们。然而，如果我们在 CPS 中重写这段代码，就会产生依赖关系，编译器将被迫按顺序计算这两行！</font></font></font></p>
<pre>System.out.println("Please enter your name: ", System.in.readLine);
</pre>
<p>In this case <em>println</em> needs to call <em>readLine</em> with its result and return the result of <em>readLine</em>. This
allows us to ensure that the two lines are executed in order <em>and</em> that <em>readLine</em> is evaluated at all (because the
whole computation expects the last value as a result). In case of Java <em>println</em> returns <em>void</em>
but if it were to return an abstract value (that <em>readLine</em> would accept), we'd solve our problem! Of course chaining
function calls like that will quickly become unreadable, but it isn't necessary. We could add syntactic sugar to the language that
will allow us to simply type expressions in order, and the compiler would chain the calls for us automatically. We can now
evaluate expressions in any order we wish without losing any of the benefits of FP (including the ability to reason about our
programs mathematically)! If this is still confusing, remember that a function is just an instance of a class with one member.
Rewrite above two lines so that <em>println</em> and <em>readLine</em> are instances of classes and everything will become clear.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>在这种情况下，println 需要调用 readLine 的结果，并返回 readLine 的结果。这样我们就能确保这两行按顺序执行，而且 readLine 也能得到计算结果（因为整个计算都希望得到最后一个值）。在 Java 中 println 返回 void，但如果它返回一个抽象值（readLine 可以接受），我们的问题就迎刃而解了！当然，这样的函数调用链很快就会变得不可读，但该形式并非是必须的。我们可以在语言中添加语法糖，这样就可以简单地按顺序键入表达式，编译器就会自动为我们链式调用。现在，我们可以按照任何顺序对表达式进行运算，而不会失去 FP 的任何优点（包括对程序予以数学推理的能力）！如果还是不明白，请记得函数只是一个类的实例并且只有一个成员。重写以上两行，使 println 和 readLine 成为类的实例，一切就会变得清晰起来。</font></font></font></p>
<p>I would now wrap up this section, except that we've only scratched the surface of continuations and their usefulness. We can write
entire programs in CPS, where every function takes an extra continuation argument and passes the result to it. We can also convert
any program to CPS simply by treating functions as special cases of continuations (functions that always return to their caller). This
conversion is trivial to do automatically (in fact, many compilers do just that).<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>我本想就此结束本节内容，但我们才刚刚触及连续函数及其实用性的表面。我们可以用 CPS 编写整个程序，其中的每个函数都会接收一个额外的连续参数，并将结果传给它。我们还可以将函数视为连续函数的特例（总是返回给调用者的函数），从而将任何程序转换为 CPS。自动完成这种转换非常容易（事实上，许多编译器就是这么做的）。</font></font></font></p>
<p>Once we convert a program to CPS it becomes clear that every instruction has some continuation, a function it will call with the result,
which in a regular program would be a place it must return to. Let's
pick any instruction from above code, say <em>add(5, 10)</em>. In a program written in CPS style it's clear what <em>add</em>'s
continuation is - it's a function that <em>add</em> calls once it's done. But what is it in a non-CPS program? We could, of course, convert
the program to CPS, but do we have to?<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>一旦我们将程序转换为 CPS，就会清楚地看到，每条指令都有一些延续，即它将用结果调用的函数，在常规程序中，这将是它必须返回的地方。让我们从上面的代码中选择任何指令，比如 add(5, 10) 。在以 CPS 风格编写的程序中可以对 add 的延续是什么很清楚 —— 它是一个在完成后调用 add 的函数。但非 CPS 程序中的它是什么？当然，我们可以将程序转换为 CPS，但是我们必须这样做吗？</font></font></font></p>
<p>It turns out that we don't. Look carefully at our CPS conversion. If you try to write a compiler for it and think about it long
enough you'll realize that the CPS version needs no stack! No function ever "returns" in the traditional sense, it just calls another
function with the result instead. We don't need to push function arguments on the stack with every call and then pop them back, we can
simply store them in some block of memory and use a jump instruction instead. We'll never need the original arguments - they'll never
be used again since no function ever returns!<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>事实证明我们没有。仔细看看我们的 CPS 转换。如果您尝试为其编写一个编译器并思考足够长的时间，您就会意识到 CPS 版本不需要堆栈！没有任何函数会在传统意义上“返回”，它只是用结果调用另一个函数。我们不需要每次调用都把函数参数推到堆栈上，然后再弹回来，我们可以简单地把它们存储在某个内存块中，然后使用跳转指令来代替。我们永远不需要原始参数 —— 它们是永远不会被再次使用的，因为根本就没有什么函数返回！</font></font></font></p>
<p>So, programs written in CPS style have no stack but have an extra argument with a function to call. Programs not written in CPS
style have no argument with a function to call, but have the stack instead. What does the stack contain? Simply the arguments, and a
pointer to memory where the function should return. Do you see a light bulb? The stack simply contains continuation information! The
pointer to the return instruction in the stack is essentially the same thing as the function to call in CPS programs! If you wanted to find out what
continuation for <em>add(5, 10)</em> is, you'd simply have to examine the stack at the point of its execution!<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>因此，用 CPS 风格编写的程序没有堆栈，但有一个额外的参数，让你能提供一个函数以供（之后的）调用。而非 CPS 风格编写的程序则没有要调用函数的参数，但有堆栈。堆栈包含什么？简单来说就是参数，以及指向函数应该返回的内存的指针。看到要点没？堆栈只包含有关于延续的信息！堆栈中返回指令的指针与 CPS 程序中调用的函数基本相同！如果你想知道 add(5, 10) 的继续信息是什么，只需在执行时看看堆栈就好了！<i>（译注：这不就是把命令式语言的只有运行时才能必须通过特定工具来直接直接观察的栈状态给直接在代码上体现出来了嘛！）</i></font></font></font></p>
<p>So that was easy. A continuation and a pointer to the return instruction in the stack are really the same thing, only a continuation
is passed explicitly, so that it doesn't need to be the same place where the function was called from. If you remember that a continuation
is a function, and a function in our language is compiled to an instance of a class, you'll realize that a pointer to the return
instruction in the stack and the continuation argument are <em>really</em> the same thing, since our function (just like an instance
of a class) is simply a pointer. This means that at any given point in time in your program you can ask for a <em>current continuation</em>
(which is simply the information on the stack).<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>所以事情就简单了。续程和指向栈中返回指令的指针其实是一回事，只不过续程是显式传递的，因此它不需要与函数的调用位置相同。如果你还记得，continuation 是一个函数，而在我们的语言中，函数被编译成类的实例，那么你就会意识到，堆栈中返回指令的指针和 continuation 参数其实是一回事，因为我们的函数（就像类的实例一样）只是一个指针。这意味着，在程序中的任何给定时间点，你都可以请求当前的续程（即栈中的信息）。</font></font></font></p>
<p>Ok, so we know what a current continuation is. What does it mean? When we get a current continuation and store it somewhere, we end up
storing the current state of our program - freezing it in time. This is similar to an OS putting itself into hibernation. A continuation
object contains the information necessary to restart the program from the point where the continuation object was acquired. An operating
system does this to your program all the time when it context switches between the threads. The only difference is that it keeps all
the control. If you ask for a continuation object (in Scheme this is done by calling <em>call-with-current-continuation</em> function)
you'll get an object that contains the current continuation - the stack (or in a CPS case the function to call next). You can store this
object in a variable (or alternatively, on disk). When you choose to "restart" your program with this continuation object you will
"transform" to the state of the program when you grabbed the continuation object. It's the same thing as switching back to a suspended
thread or waking up an OS from hibernation, except you can do it again and again. When an OS wakes up, the hibernation information is
destroyed. If it wasn't, you'd be able to wake up from the same point over and over again, almost like going back in time. You have
that control with continuations!<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>好了，我们可以知道当前的续程是什么。这意味着什么？当我们获取一个当前续程并将其存储在某处时，我们最终存储了程序的当前状态 —— 将它在某一刻冻结。这类似于操作系统进入休眠状态。续程对象包含了从获取续程对象时重新启动程序所需的信息。操作系统在线程间进行上下文切换时，也会这样做。唯一不同的是，它保留了所有控制权。如果你请求一个续程对象（在 Scheme 中，这是通过调用 call-with-current-continuation 函数实现的），你将得到一个包含当前续程的对象 —— 栈（或，在 CPS 中，即使下一个要调用的函数）。您可以将该对象存储在一个变量中（或者存储在磁盘上）。当你选择用这个续程对象“重启”程序时，你将“转换”到抓取续程对象时的程序状态。这与切换回悬浮线程或从休眠状态唤醒操作系统的过程是一样的，只不过你可以反复这样做。当操作系统唤醒时，休眠信息会被销毁。如果不这样做，你就可以一次又一次地从同一个点唤醒，几乎就像回到过去一样：有了续程的特性，也就有了这一掌控能力！</font></font></font></p>
<p>In what situations are continuations useful? Usually when you're trying to simulate state in an application of inherently stateless
nature to ease your life. A great application of continuations are <a href=http://www.seaside.st/>web applications</a>. Microsoft's
ASP.NET goes to tremendous lengths to try and simulate state so that you can write your application with less hassle. If C#
supported continuations half of ASP.NET's complexity would disappear - you'd simply store a continuation and restart it when a user
makes the web request again. To a programmer of the web application there would be no interruption - the program would simply start
from the next line! Continuations are an incredibly useful abstraction for some problems. Considering that many of the traditional
fat clients are moving to the web, continuations will become more and more important in the future.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>续程在什么情况下有用？通常是在无状态应用程序中模拟状态，以减轻工作压力。网络应用程序就是一个很好的续程应用。微软的 ASP.NET 在模拟状态方面做了大量工作，这样您在编写应用程序时就可以少走很多弯路。如果 C# 支持续程，ASP.NET 的复杂性将消失一半 —— 您只需存储一个续程，然后在用户再次发出网络请求时重新启动它。对于网络应用程序的程序员来说，这不会造成任何中断 —— 程序只需从下一行开始！对于某些问题来说，续程是一个非常有用的抽象概念。考虑到许多传统的胖客户端正在转为 Web 应用，续程在未来将变得越来越重要。</font></font></font></p>
 <h2><a id=part_10>Pattern Matching<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> 模式匹配</font></font></font></a></h2>
<p class=first>Pattern matching is not a new or innovative feature. In fact, it has little to do with functional programming. The only
reason why it's usually attributed to FP is that functional languages have had pattern matching for some time, while modern imperative
languages still don't.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>模式匹配并不是一个新特性或新发明。其实和函数式编程关系不大。通常将其归因于 FP 的唯一原因是函数式语言已经具有模式匹配一​​段时间了，而现代命令式语言仍然没有。</font></font></font></p>
<p>Let's dive into pattern matching with an example. Here's a Fibonacci function in Java:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>让我们通过一个例子来深入了解模式匹配。这是 Java 中的斐波那契函数：</font></font></font></p>
<pre>int fib(int n) {
    if(n == 0) return 1;
    if(n == 1) return 1;
        
    return fib(n - 2) + fib(n - 1);
}
</pre>
<p>And here's an example of a Fibonacci function in our Java-derived language that supports pattern matching:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>下面是我们的 Java 派生语言中支持模式匹配的斐波那契函数示例：</font></font></font></p>
<pre>int fib(0) {
    return 1;
}
int fib(1) {
    return 1;
}
int fib(int n) {
    return fib(n - 2) + fib(n - 1);
}
</pre>
<p>What's the difference? The compiler implements branching for us.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>有什么不同？编译器为我们实现了分支。<i>（译注： Prolog, Erlang, Elixir 等语言就是原生支持这种语法的。在这样的语法设计下，尾调用可向 GOTO 转换的可能性就能显而易见地被摆在你眼前（而 Erlang 中的尾调用似乎就是要被这样编译的）。）</i></font></font></font></p>
<p>What's the big deal? There isn't any. Someone noticed that a large number of functions contain very complicated switch statements
(this is particularly true about functional programs) and decided that it's a good idea to abstract that away. We split the function
definition into multiple ones, and put patterns in place of some arguments (sort of like overloading). When the function is called, the
compiler compares the arguments with the definitions at runtime, and picks the correct one. This is usually done by picking the most
specific definition available. For example, <em>int fib(int n)</em> can be called with <em>n</em> equal to <em>1</em>, but it isn't
because <em>int fib(1)</em> is more specific.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>有什么大不了的？没有。有人注意到大量函数包含非常复杂的 switch 语句（对于函数式程序尤其如此），并认为将其抽象出来是个好主意。我们将函数定义分成多个定义，并用模式代替一些参数（有点像重载）。当函数被调用时，编译器会在运行时将参数与定义进行比较，并选择正确的一个。这通常是通过选择可用的最具体的定义来完成的。例如，可以在 n 等于 1 时调用 int fib(int n)，但事实并非如此，因为 int fib(1) 更具体。</font></font></font></p>
<p>Pattern matching is usually more complex than our example reveals. For example, an advanced pattern matching system will allow us to
do the following:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>模式匹配通常比我们的示例所揭示的更复杂。例如，高级模式匹配系统将允许我们执行以下操作：</font></font></font></p>
<pre>int f(int n &lt; 10) { ... }
int f(int n) { ... }
</pre>
<p>When is pattern matching useful? In a surprisingly large number of cases! Every time you have a complex structure of nested <em>if</em>s,
pattern matching can do a better job with less code on your part. A good function that comes to mind is a standard <em>WndProc</em>
function that all Win32 applications must provide (even though it's often abstracted away). Usually a pattern matching system can
examine collections as well as simple values. For example, if you pass an array to your function you could pick out all arrays in which
the first element is equal to <em>1</em> and the third element is greater than <em>3</em>.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>模式匹配什么时候有用？数量惊人！每当您拥有复杂的嵌套 if 结构时，模式匹配都可以用更少的代码完成更好的工作。我想到的一个好函数是所有 Win32 应用程序都必须提供的标准 WndProc 函数（尽管它经常被抽象掉）。通常，模式匹配系统可以检查集合以及简单值。例如，如果将一个数组传递给函数，您可以选出第一个元素等于 1 并且第三个元素大于 3 的所有数组。<i>（译注：函数式风格的语法设计中一般会让模式匹配天然具备解包的能力，从而再复杂的数据逻辑也可以像写产品需求书一样无比直观地就这么直接写出来。）</i></font></font></font></p>
<p>Another benefit of pattern matching is that if you need to add or modify conditions, you don't have to go into one huge function.
You simply add (or modify) appropriate definitions. This eliminates the need for a whole range of design patterns from the GoF book.
The more complex your conditions are, the more pattern matching will help you. Once you're used to it, you
start wondering how you ever got through your day without it.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>模式匹配的另一个好处是，如果您需要添加或修改条件，则不必进入一个庞大的函数。您只需添加（或修改）适当的定义即可。这样就不再需要 GoF 书中的一整套设计模式。您的条件越复杂，模式匹配对您的帮助就越大。一旦你习惯了它，你就会开始想知道没有它你是如何度过这一天的。</font></font></font></p>
<h2><a id=part_11>Closures<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> 闭包</font></font></font></a></h2>
<p class=first>So far we've discussed features in the context of "pure" functional languages -
languages that are implementations of lambda calculus and don't include features
that conflict with Church's formalism. However, many of the features of functional
languages are useful outside of lambda calculus framework. While an implementation
of an axiomatic system is useful because it allows thinking about programs in terms
of mathematical expressions, it may or may not always be practical. Many languages
choose to incorporate functional elements without strictly adhering to functional
doctrine. Many such languages (like Common Lisp) don't require variables to be final
- you can modify things in place. They also don't require functions to depend only
on their arguments - functions are allowed to access state outside of their boundaries.
But they do include functional features - like higher order functions. Passing functions
around in impure languages is a little bit different than doing it in the confines
of lambda calculus and requires support for an interesting feature often referred
to as lexical closure. Let's take a look at some sample code. Remember, in this
case variables aren't final and functions can refer to variables outside of their
scope:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>到目前为止，我们已经讨论了“纯”函数式语言中面貌 —— 这些语言是 lambda 演算的实现，并且不包含与 Church 形式论相冲突的性征。然而，函数式语言的许多性征在 lambda 演算框架之外也很有用。虽然公理系统的实现是有用的，因为它允许用数学表达式来思考程序，但它不一定总是实用的。许多语言选择在不严格遵守函数学说的情况下融入函数元素。许多这样的语言（比如 Common Lisp）不要求变量是最终（即不可变）的 —— 你可以就地修改。它们也不要求函数仅依赖于它们的参数 —— 允许函数访问其边界之外的状态。但它们确实包含函数式特征 —— 比如高阶函数。在不纯语言中传递函数与在 lambda 演算的范围内传递函数有点不同，并且需要支持一个有趣的特性，这通常称为词法闭包。让我们看一些示例代码。请记住，在这种情况下，变量不是最终（ final ）的，函数可以引用其范围之外的变量：</font></font></font></p>
<pre>Function makePowerFn(int power) {
   int powerFn(int base) {
       return pow(base, power);
   }

   return powerFn;
}

Function square = makePowerFn(2);
square(3); // returns 9
</pre>
<p>The function <em>make-power-fn</em> returns a function that takes a single
argument and raises it to a certain power. What happens when we try to
evaluate <em>square(3)</em>? The variable <em>power</em> isn't anywhere in scope of
<em>powerFn</em> because <em>makePowerFn</em> has returned and its stack is long gone.
How can <em>square</em> work, then? The language must, somehow, store the value
of <em>power</em> somewhere for <em>square</em> to work. What if we create another
function, <em>cube</em>, that raises something to the third power? The runtime
must now store two copies of power, one for each function we generated
using <em>make-power-fn</em>. The phenomenon of storing these values is called a
<em>closure</em>. Closures don't only store arguments of a host function. For
example, a closure can look like this:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>函数 make-power-fn 返回一个接受单个参数并将其提升到某个幂的函数。当我们尝试计算 square(3) 时会发生什么？变量 power 不在 powerFn 范围内的任何位置，因为 makePowerFn 已返回并且其堆栈早已消失。那么 Square 是如何工作的呢？该语言必须以某种方式将 power 的值存储在某处，以便 square 能够工作。如果我们创建另一个函数（cube）来求三次方呢？运行时现在必须存储两份 power 副本，一份用于我们使用 make-power-fn 生成的每个函数。存储这些值的现象称为闭包。闭包不仅仅存储宿主函数的参数。例如，闭包可以如下所示<i>（译注：从下面你能看到，基于词法闭包的支持，你获得了一种更简单的 OOP 系统：函数的定义即类的定义，函数的执行即构造闭包，而这对应于类构造作为它实例的对象。问题在于， OOP 系统的设定必须专门加以了解，但词法闭包会做什么只需要学会词法闭包会做什么就足够了 —— 这才是真正的无关语言！😊）</i>：</font></font></font></p>
<pre>Function makeIncrementer() {
   int n = 0;

   int increment() {
       return ++n;
   }
}

Function inc1 = makeIncrementer();
Function inc2 = makeIncrementer();

inc1(); // returns 1;
inc1(); // returns 2;
inc1(); // returns 3;
inc2(); // returns 1;
inc2(); // returns 2;
inc2(); // returns 3;
</pre>
<p>The runtime manages to store <em>n</em>, so incrementers can access it.
Furthermore, it stores various copies, one for each incrementer, even
though they're supposed to disappear when <em>makeIncrementer</em> returns.
What does this code compile to? How do closures work behind the
scenes? Fortunately, we have a back stage pass.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>运行时设法存储 n，因此增量器可以访问它。此外，它存储各种副本，每个增量器一个，即使它们应该在 makeIncrementer 返回时消失。这段代码编译成什么？闭包在幕后是如何工作的？幸运的是，我们有后台通行证。</font></font></font></p>
<p>A little common sense goes a long way. The first observation is that
local variables are no longer limited to simple scope rules and have
an undefined lifetime. The obvious conclusion is that they're no
longer stored on the stack - they must be stored on the heap instead<sup><a href=#gc-alloc-speed>8</a></sup>.
A closure, then, is implemented just like a function we discussed
earlier, except that it has an additional reference to the surrounding
variables:<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>一点常识会有很大帮助。第一个观察结果是局部变量不再局限于简单的作用域规则并且具有未定义的生命周期。明显的结论是它们不再存储在堆栈上 —— 而是它们必须存储在堆上 <sup><a href=#gc-alloc-speed>8</a></sup> 。那么，闭包的实现就像我们之前讨论的函数一样，只是它有一个对周围变量的额外引用：</font></font></font></p>
<pre>class some_function_t {
   SymbolTable parentScope;
   
   // ...
}
</pre>
<p>When a closure references a variable that's not in its local scope, it
consults this reference for a parent scope. That's it! Closures bring functional and
OO worlds closer together. Every time you create a class that holds some state and pass it to somewhere else, think
of closures. A closure is just an object
that creates "member variables" on the fly by grabbing them from the scope,
so you don't have to!<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>当闭包引用不在其本身作用域中的变量时，它会查阅该引用以获取父作用域。就是这样！闭包使函数世界和面向对象世界更加紧密地结合在一起。每次创建一个保存某种状态的类并将其传递到其他地方时，请考虑闭包。闭包只是一个对象，它通过从作用域中获取“成员变量”来动态创建“成员变量”，从而使您不必亲自手动去做这件事！<i>（译注：像这样的闭包是一种无比优雅的实现方案。因为它能自己拿到自己需要的并打包好（而不是在执行的时候去调用处找它缺失的），并且，它也只会拿上它需要的，如同一个天然就能将自己优化到极致的 OCI 容器。我有理由相信 Docker 容器在设计的时候完全有可能是借鉴了闭包的思想，即程序与必要上下文一同打包从而省去部署时候上下文缺失的可能，但容器本身与早它好久诞生的闭包相比却是仍然挫的不得了：它甚至没有能力只获取它需要的上下文。这是来自 Unix 的不妥当的设计（但它的信徒们一般会毫无建设性地说这是什么工业特性）而导致的，这属于那种因为那种由于先前的无能而刻意造成的知识，你学它只是因为一个垃圾设计你不得不用了而已。 Docker 更像是借助优秀设计中的点子对垃圾设计的使用技巧做出最后竭力的补充。即便它因此不可能做得出一个像被借鉴的东西一样的补充效果、不能做到闭包有的能耐这补充也都能有，但是，它仍能因为借鉴了足够优秀优雅的设计而成为了一个极具价值的补充。事实上，学术界和工业界并不见得必须要冲突。恰恰是一知半解都能找到工作、只是因为自己的某种身份属性或特定能力让自己具备了足够的被资本符号系统收买的价值，然后他们就在他们的位置上工作了 —— 不论他们是否产出价值，更不论这样的位置是否能为人类社会产出价值 …… 资产阶级喜欢把自己的痛痒直接等同为人类社会的痛痒也不是一两次了。）</i></font></font></font></p>
<h2><a id=part_12>What's next?<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> 下一步是什么？</font></font></font></a></h2>
<p class=first>This article only scratches the surface of functional programming. Sometimes a small scratch
can progress to something bigger and in our case it's a good thing. In the future I plan to write about
category theory, monads, functional data structures, type systems in functional languages,
functional concurrency, functional databases and much more. If I get to write (and in the process learn) about
half of these topics my life will be complete. In the meantime, <a href=http://www.google.com/>Google</a>
is our friend.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>本文仅涉及函数式编程的皮毛。有时，一个小划痕可能会发展成更大的划痕。在我们的例子中，这是一件好事。将来我计划写范畴论、单子、函数数据结构、函数语言中的类型系统、函数并发、函数数据库等等。如果我能写（并在这个过程中学习）这些主题中的大约一半，我的生活就完整了。与此同时，网络搜索引擎也是我们的朋友。</font></font></font></p>
<h2><a id=part_13>Comments?<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><font class=notranslate data-immersive-translate-translation-element-mark=1>&nbsp;</font><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-inline-wrapper-theme-dividingLine immersive-translate-target-translation-inline-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> 评论？</font></font></font></a></h2>
<p class=first>If you have any questions, comments, or suggestions, please drop a note at <a href=mailto:coffeemug@gmail.com>coffeemug@gmail.com</a>.
 I'll be glad to hear your feedback.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1>如果您有任何问题、意见或建议，请发送邮件至 coffeemug@gmail.com 。我很高兴听到您的反馈。</font></font></font></p>
<hr>
<div id=footnotes>
<p><sup><a id=ask-a-manager>1</a></sup>When I was looking for a job in the fall of 2005 I often did ask this question.
It's quite amusing how many blank stares I got. You would think that at about $300,000 a piece these people would
at least have a good understanding of most tools available to them.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> <sup><a id=ask-a-manager>1</a></sup> 当我在2005年秋天找工作时，我经常问这个问题。有趣的是我得到了不少的白眼。咱可能会觉得，这些人每个的工资都得大约 300,000 美元，那么他们至少得对大多数可用的工具能有点了解（但事实上显然不）。</font></font></font></p>
<p><sup><a id=universe-math>2</a></sup>This appears to be a controversial question. Physicists and mathematicians
are forced to acknowledge that it isn't at all clear whether everything in the universe obeys the laws that can be
described by mathematics.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> <sup><a id=universe-math>2</a></sup> 这似乎是一个有争议的问题。物理学家和数学家被迫承认，宇宙中的一切是否都遵守数学可以描述的定律根本不清楚。<i>（译注：基本上任何做足够认真的研究的，不论其领域如何，其都会有类似体验。这其实就是对“断裂普遍存在”或者说“根本不存在一个整全大他者”的这么一个事实的体验，而体验到这种事的前提就是，你愿意为了贯彻你的认真而抛弃一切令你感到不论再多安宁的幻想。）</i></font></font></font></p>
<p><sup><a id=history>3</a></sup>I've always hated history lessons that offer a dry chronology of dates, names,
and events. To me history is about the lives of people who changed the world. It is about their private
reasons behind their actions, and the mechanisms by which they affected millions of souls. For this reason this history
section is hopelessly incomplete. Only very relevant people and events are discussed.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> <sup><a id=history>3</a></sup> 我一直讨厌提供枯燥的日期、名称和事件年表的历史课。对我来说，历史是关于改变世界的人们的生活。这是有关他们行动背后的私人原因、以及他们如何影响数百万灵魂的机制。因此，这段历史部分是极其不完整的。仅讨论非常相关的人物和事件。</font></font></font></p>
<p><sup><a id=lambda>4</a></sup>When I was learning about functional programming I was very annoyed by
the term "lambda" because I couldn't really understand what it really means. In this context lambda is a
function, the single Greek letter was just easier to write in a mathematical notation. Every time you
hear "lambda" when talking about functional programming just translate it in your mind to "function".<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> <sup><a id=lambda>4</a></sup> 当我学习函数式编程时，我对 “lambda” 这个术语感到非常恼火，因为我无法真正理解它的真正含义。在这种情况下， lambda 是一个函数，单个希腊字母更容易用数学符号书写。每当您在谈论函数式编程时听到 “lambda” 时，只需在您的脑海中将其翻译为“函数”即可。</font></font></font></p>
<p><sup><a id=strings-final>5</a></sup>Interestingly Java strings are immutable anyway. It's rather interesting
to explore the reasons for this treachery, but that would distract us from our goal.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> <sup><a id=strings-final>5</a></sup> 有趣的是，Java 字符串无论如何都是不可变的。探索这种背叛的原因是相当有趣的，但这会分散我们对目标的注意力。</font></font></font></p>
<p><sup><a id=tail-calls>6</a></sup>Most functional language compilers optimize recursive functions by
transforming them to their iterative alternatives whenever possible. This is called a <a href=http://en.wikipedia.org/wiki/Tail_recursion>tail call
optimization</a>.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> <sup><a id=tail-calls>6</a></sup> 大多数函数式语言编译器都会尽可能将递归函数转换为迭代替代函数来优化递归函数。这称为尾调用优化。</font></font></font></p>
<p><sup><a id=proof>7</a></sup>The opposite isn't always true. While it is sometimes possible to prove that two pieces
of code are equivalent, it isn't possible in all situations.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> <sup><a id=proof>7</a></sup> 相反的情况并不总是正确的。虽然有时可以证明两段代码是等效的，但并非在所有情况下都可以。</font></font></font></p>
<p><sup><a id=gc-alloc-speed>8</a></sup>This is actually no slower than storing on the stack because once
you introduce a garbage collector, memory allocation becomes an O(1) operation.<font class="notranslate immersive-translate-target-wrapper" lang=zh-CN data-immersive-translate-translation-element-mark=1><br><font class="notranslate immersive-translate-target-translation-theme-dividingLine immersive-translate-target-translation-block-wrapper-theme-dividingLine immersive-translate-target-translation-block-wrapper" data-immersive-translate-translation-element-mark=1><font class="notranslate immersive-translate-target-inner immersive-translate-target-translation-theme-dividingLine-inner" data-immersive-translate-translation-element-mark=1> <sup><a id=gc-alloc-speed>8</a></sup> 这实际上并不比存储在堆栈上慢，因为一旦引入垃圾收集器，内存分配就变成了 O(1) 操作。</font></font></font></p>
</div>
 </div><a class="u-url sf-hidden" href=https://www.defmacro.org/2006/06/19/fp.html hidden></a>
</article>
 </div>
 </main><footer class=site-footer translate=no>
 <div class=wrapper>
 <div class=footer-col-wrapper>
 <div class="footer-col footer-col-1">
 <ul class=social-media-list>
 
 <li>
 <a href=https://twitter.com/spakhm><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width=16px height=16px><path fill=#828282 d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path></svg>
</span><span class=username>spakhm</span></a>
 </li>
 
 
 <li>
 <p class=rss-subscribe>Subscribe <a href=https://www.defmacro.org/feed.xml>via RSS</a></p>
 </li>
 </ul>
 </div>
 </div>
 </div>
</footer>
<single-file-infobar><template shadowroot=open><div><style>.infobar,.infobar .infobar-icon,.infobar .infobar-link-icon {min-inline-size:28px;min-block-size:28px;box-sizing:border-box;}.infobar,.infobar .infobar-close-icon,.infobar .infobar-link-icon {opacity:0.7;transition:opacity 250ms;}.infobar:hover,.infobar .infobar-close-icon:hover,.infobar .infobar-link-icon:hover {opacity:1;}.infobar,.infobar-content {display:flex;}.infobar {position:fixed;top:16px;right:16px;margin-inline-start:16px;margin-block-end:16px;color:#2d2d2d;background-color:#737373;border:2px solid;border-color:#eee;border-radius:16px;z-index:2147483647;}.infobar:valid,.infobar:not(:focus-within) .infobar-content {display:none;}.infobar:focus-within {background-color:#f9f9f9;border-color:#878787;border-radius:8px;opacity:1;transition-property:opacity,background-color,border-color,border-radius,color;}.infobar-content {align-items:center;}.infobar-content span {font-family:Arial,Helvetica,sans-serif;font-size:14px;line-height:18px;word-break:break-word;white-space:pre-wrap;margin-inline:4px;margin-block:4px;}.infobar .infobar-icon,.infobar .infobar-close-icon,.infobar .infobar-link-icon {cursor:pointer;background-position:center;background-repeat:no-repeat;}.infobar .infobar-close-icon,.infobar .infobar-link-icon {align-self:flex-start;}.infobar .infobar-icon {position:absolute;min-inline-size:24px;min-block-size:24px;}.infobar:focus-within .infobar-icon {z-index:-1;background-image:none;}.infobar .infobar-close-icon {min-inline-size:22px;min-block-size:22px;}.infobar .infobar-icon {background-color:transparent;background-size:70%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABABAMAAABYR2ztAAABhmlDQ1BJQ0MgcHJvZmlsZQAAKJF9kj1Iw0AYht+mSkUrDnYQcchQnSyIijqWKhbBQmkrtOpgcukfNGlIUlwcBdeCgz+LVQcXZ10dXAVB8AfEydFJ0UVK/C4ptIjx4LiH9+59+e67A4RGhalm1wSgapaRisfEbG5VDLyiDwEAvZiVmKkn0osZeI6ve/j4ehfhWd7n/hz9St5kgE8kjjLdsIg3iGc2LZ3zPnGIlSSF+Jx43KACiR+5Lrv8xrnosMAzQ0YmNU8cIhaLHSx3MCsZKvE0cVhRNcoXsi4rnLc4q5Uaa9XJbxjMaytprtMcQRxLSCAJETJqKKMCCxFaNVJMpGg/5uEfdvxJcsnkKoORYwFVqJAcP/gb/O6tWZiadJOCMaD7xbY/RoHALtCs2/b3sW03TwD/M3Cltf3VBjD3SXq9rYWPgIFt4OK6rcl7wOUOMPSkS4bkSH6aQqEAvJ/RM+WAwVv6EGtu31r7OH0AMtSr5Rvg4BAYK1L2use9ezr79u+ZVv9+AFlNcp0UUpiqAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5AsHADIRLMaOHwAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAPUExURQAAAIqKioyNjY2OjvDw8L2y1DEAAAABdFJOUwBA5thmAAAAAWJLR0QB/wIt3gAAAGNJREFUSMdjYCAJsLi4OBCQx6/CBQwIGIDPCBcXAkYQUsACU+AwlBVQHg6Eg5pgZBGOboIJZugDFwRwoJECJCUOhJI1wZwzqmBUwagCuipgIqTABG9h7YIKaKGAURAFEF/6AQAO4HqSoDP8bgAAAABJRU5ErkJggg==);}.infobar .infobar-link-icon {background-size:60%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAgMAAADXB5lNAAABhmlDQ1BJQ0MgcHJvZmlsZQAAKJF9kj1Iw0AYht+mSkUrDnYQcchQnSyIijqWKhbBQmkrtOpgcukfNGlIUlwcBdeCgz+LVQcXZ10dXAVB8AfEydFJ0UVK/C4ptIjx4LiH9+59+e67A4RGhalm1wSgapaRisfEbG5VDLyiDwEAvZiVmKkn0osZeI6ve/j4ehfhWd7n/hz9St5kgE8kjjLdsIg3iGc2LZ3zPnGIlSSF+Jx43KACiR+5Lrv8xrnosMAzQ0YmNU8cIhaLHSx3MCsZKvE0cVhRNcoXsi4rnLc4q5Uaa9XJbxjMaytprtMcQRxLSCAJETJqKKMCCxFaNVJMpGg/5uEfdvxJcsnkKoORYwFVqJAcP/gb/O6tWZiadJOCMaD7xbY/RoHALtCs2/b3sW03TwD/M3Cltf3VBjD3SXq9rYWPgIFt4OK6rcl7wOUOMPSkS4bkSH6aQqEAvJ/RM+WAwVv6EGtu31r7OH0AMtSr5Rvg4BAYK1L2use9ezr79u+ZVv9+AFlNcp0UUpiqAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5AsHAB8H+DhhoQAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAJUExURQAAAICHi4qKioTuJAkAAAABdFJOUwBA5thmAAAAAWJLR0QCZgt8ZAAAAJJJREFUOI3t070NRCEMA2CnYAOyDyPwpHj/Va7hJ3FzV7zy3ET5JIwoAF6Jk4wzAJAkzxAYG9YRTgB+24wBgKmfrGAKTcEfAY4KRlRoIeBTgKOCERVaCPgU4Khge2GqKOBTgKOCERVaAEC/4PNcnyoSWHpjqkhwKxbcig0Q6AorXYF/+A6eIYD1lVbwG/jdA6/kA2THRAURVubcAAAAAElFTkSuQmCC);}.infobar .infobar-close-icon {appearance:none;background-size:80%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAgMAAADXB5lNAAABhmlDQ1BJQ0MgcHJvZmlsZQAAKJF9kj1Iw0AYht+mSkUrDnYQcchQnSyIijqWKhbBQmkrtOpgcukfNGlIUlwcBdeCgz+LVQcXZ10dXAVB8AfEydFJ0UVK/C4ptIjx4LiH9+59+e67A4RGhalm1wSgapaRisfEbG5VDLyiDwEAvZiVmKkn0osZeI6ve/j4ehfhWd7n/hz9St5kgE8kjjLdsIg3iGc2LZ3zPnGIlSSF+Jx43KACiR+5Lrv8xrnosMAzQ0YmNU8cIhaLHSx3MCsZKvE0cVhRNcoXsi4rnLc4q5Uaa9XJbxjMaytprtMcQRxLSCAJETJqKKMCCxFaNVJMpGg/5uEfdvxJcsnkKoORYwFVqJAcP/gb/O6tWZiadJOCMaD7xbY/RoHALtCs2/b3sW03TwD/M3Cltf3VBjD3SXq9rYWPgIFt4OK6rcl7wOUOMPSkS4bkSH6aQqEAvJ/RM+WAwVv6EGtu31r7OH0AMtSr5Rvg4BAYK1L2use9ezr79u+ZVv9+AFlNcp0UUpiqAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH5AsHAB8VC4EQ6QAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAJUExURQAAAICHi4qKioTuJAkAAAABdFJOUwBA5thmAAAAAWJLR0QCZgt8ZAAAAJtJREFUOI3NkrsBgCAMRLFwBPdxBArcfxXFkO8rbKWAAJfHJ9faf9vuYX/749T5NmShm3bEwbe2SxeuM4+2oxDL1cDoKtVUjRy+tH78Cv2CS+wIiQNC1AEhk4AQeUTMWUJMfUJMSEJMSEY8kIx4IONroaYAimNxsXp1PA7PxwfVL8QnowwoVC0lig07wDDVUjAdbAnjwtow/z/bDW7eI4M2KruJAAAAAElFTkSuQmCC);}</style><form class="infobar"><span tabindex="-1" class="infobar-icon"></span><span tabindex="-1" class="infobar-content"><input type="checkbox" required="" class="infobar-close-icon"><span>Mon Aug 28 2023 17:13:40 GMT+0800 (中国标准时间)</span><a class="infobar-link-icon" target="_blank" rel="noopener noreferrer" title="Open source URL: https://www.defmacro.org/2006/06/19/fp.html" href="https://www.defmacro.org/2006/06/19/fp.html"></a></span></form><script>function M(e,{saveUrl:t,infobarContent:n,saveDate:r}){if(t){const a=e.querySelector("single-file-infobar").shadowRoot;a.querySelector(".infobar-content span").textContent=n||r;a.querySelector(".infobar-content .infobar-link-icon").href=t}}function P(e){const t=e.evaluate("//comment()",e,null,XPathResult.FIRST_ORDERED_NODE_TYPE,null);let n=t&&t.singleNodeValue;if(n&&n.nodeType==Node.COMMENT_NODE&&n.textContent.includes("SingleFile")){const e=n.textContent.split("\n"),[,,t,...r]=e,a=t.match(/^ url: (.*) ?$/),o=a&&a[1];if(o){let e,t;if(r.length&&(t=r[0].split("saved date: ")[1],t&&r.shift(),r.length>1)){let t=r[0].split("info: ")[1].trim();for(let e=1;e<r.length-1;e++)t+="\n"+r[e].trim();e=t.trim()}return{saveUrl:o,infobarContent:e,saveDate:t}}}}(function U(e){const t=P(e);t&&t.saveUrl&&M(e,t)})(document)</script></div></template></single-file-infobar><script data-template-shadow-root>(()=>{document.currentScript.remove();processNode(document);function processNode(node){node.querySelectorAll("template[shadowroot]").forEach(element=>{let shadowRoot = element.parentElement.shadowRoot;if (!shadowRoot) {try {shadowRoot=element.parentElement.attachShadow({mode:element.getAttribute("shadowroot")});shadowRoot.innerHTML=element.innerHTML;element.remove()} catch (error) {} if (shadowRoot) {processNode(shadowRoot)}}})}})()</script>